{"version":3,"sources":["../src/remote/persistent_stream.ts"],"names":[],"mappings":"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","file":"persistent_stream.js","sourcesContent":["/**\n * Copyright 2017 Google Inc.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\nimport * as api from '../protos/firestore_proto_api';\nimport { CredentialsProvider, Token } from '../api/credentials';\nimport { SnapshotVersion } from '../core/snapshot_version';\nimport { ProtoByteString, TargetId } from '../core/types';\nimport { QueryData } from '../local/query_data';\nimport { Mutation, MutationResult } from '../model/mutation';\nimport { assert } from '../util/assert';\nimport { AsyncQueue, TimerId } from '../util/async_queue';\nimport { Code, FirestoreError } from '../util/error';\nimport * as log from '../util/log';\n\nimport { ExponentialBackoff } from './backoff';\nimport { Connection, Stream } from './connection';\nimport { JsonProtoSerializer } from './serializer';\nimport { WatchChange } from './watch_change';\nimport { isNullOrUndefined } from '../util/types';\nimport { CancelablePromise } from '../util/promise';\n\nconst LOG_TAG = 'PersistentStream';\n\n// The generated proto interfaces for these class are missing the database\n// field. So we add it here.\n// TODO(b/36015800): Remove this once the api generator is fixed.\ninterface ListenRequest extends api.ListenRequest {\n  database?: string;\n}\nexport interface WriteRequest extends api.WriteRequest {\n  database?: string;\n}\n\nenum PersistentStreamState {\n  /**\n   * The streaming RPC is not running and there's no error condition.\n   * Calling `start` will start the stream immediately without backoff.\n   * While in this state isStarted will return false.\n   */\n  Initial,\n\n  /**\n   * The stream is starting, and is waiting for an auth token to attach to\n   * the initial request. While in this state, isStarted will return\n   * true but isOpen will return false.\n   */\n  Auth,\n\n  /**\n   * The streaming RPC is up and running. Requests and responses can flow\n   * freely. Both isStarted and isOpen will return true.\n   */\n  Open,\n\n  /**\n   * The stream encountered an error. The next start attempt will back off.\n   * While in this state isStarted() will return false.\n   *\n   */\n  Error,\n\n  /**\n   * An in-between state after an error where the stream is waiting before\n   * re-starting. After\n   * waiting is complete, the stream will try to open. While in this\n   * state isStarted() will return YES but isOpen will return false.\n   */\n  Backoff,\n\n  /**\n   * The stream has been explicitly stopped; no further events will be emitted.\n   */\n  Stopped\n}\n\n/**\n * Provides a common interface that is shared by the listeners for stream\n * events by the concrete implementation classes.\n */\nexport interface PersistentStreamListener {\n  /**\n   * Called after the stream was established and can accept outgoing\n   * messages\n   */\n  onOpen: () => Promise<void>;\n  /**\n   * Called after the stream has closed. If there was an error, the\n   * FirestoreError will be set.\n   */\n  onClose: (err?: FirestoreError) => Promise<void>;\n}\n\n/**\n * Initial backoff time in milliseconds after an error.\n * Set to 1s according to https://cloud.google.com/apis/design/errors.\n */\nconst BACKOFF_INITIAL_DELAY_MS = 1000;\n\n/** Maximum backoff time in milliseconds */\nconst BACKOFF_MAX_DELAY_MS = 60 * 1000;\n\nconst BACKOFF_FACTOR = 1.5;\n\n/** The time a stream stays open after it is marked idle. */\nconst IDLE_TIMEOUT_MS = 60 * 1000;\n\n/**\n * A PersistentStream is an abstract base class that represents a streaming RPC\n * to the Firestore backend. It's built on top of the connections own support\n * for streaming RPCs, and adds several critical features for our clients:\n *\n *   - Exponential backoff on failure\n *   - Authentication via CredentialsProvider\n *   - Dispatching all callbacks into the shared worker queue\n *\n * Subclasses of PersistentStream implement serialization of models to and\n * from the JSON representation of the protocol buffers for a specific\n * streaming RPC.\n *\n * ## Starting and Stopping\n *\n * Streaming RPCs are stateful and need to be `start`ed before messages can\n * be sent and received. The PersistentStream will call the onOpen function\n * of the listener once the stream is ready to accept requests.\n *\n * Should a `start` fail, PersistentStream will call the registered\n * onClose with a FirestoreError indicating what went wrong.\n *\n * A PersistentStream can be started and stopped repeatedly.\n *\n * Generic types:\n *  SendType: The type of the outgoing message of the underlying\n *    connection stream\n *  ReceiveType: The type of the incoming message of the underlying\n *    connection stream\n *  ListenerType: The type of the listener that will be used for callbacks\n */\nexport abstract class PersistentStream<\n  SendType,\n  ReceiveType,\n  ListenerType extends PersistentStreamListener\n> {\n  private state: PersistentStreamState;\n  private inactivityTimerPromise: CancelablePromise<void> | null = null;\n  private stream: Stream<SendType, ReceiveType> | null = null;\n\n  protected backoff: ExponentialBackoff;\n\n  protected listener: ListenerType | null = null;\n\n  constructor(\n    private queue: AsyncQueue,\n    connectionTimerId: TimerId,\n    private idleTimerId: TimerId,\n    protected connection: Connection,\n    private credentialsProvider: CredentialsProvider\n  ) {\n    this.backoff = new ExponentialBackoff(\n      queue,\n      connectionTimerId,\n      BACKOFF_INITIAL_DELAY_MS,\n      BACKOFF_FACTOR,\n      BACKOFF_MAX_DELAY_MS\n    );\n    this.state = PersistentStreamState.Initial;\n  }\n\n  /**\n   * Returns true if `start` has been called and no error has occurred. True\n   * indicates the stream is open or in the process of opening (which\n   * encompasses respecting backoff, getting auth tokens, and starting the\n   * actual RPC). Use `isOpen` to determine if the stream is open and ready for\n   * outbound requests.\n   */\n  isStarted(): boolean {\n    return (\n      this.state === PersistentStreamState.Backoff ||\n      this.state === PersistentStreamState.Auth ||\n      this.state === PersistentStreamState.Open\n    );\n  }\n\n  /**\n   * Returns true if the underlying RPC is open (the openHandler has been\n   * called) and the stream is ready for outbound requests.\n   */\n  isOpen(): boolean {\n    return this.state === PersistentStreamState.Open;\n  }\n\n  /**\n   * Starts the RPC. Only allowed if isStarted returns false. The stream is\n   * not immediately ready for use: onOpen will be invoked when the RPC is ready\n   * for outbound requests, at which point isOpen will return true.\n   *\n   *  When start returns, isStarted will return true.\n   */\n  start(listener: ListenerType): void {\n    if (this.state === PersistentStreamState.Error) {\n      this.performBackoff(listener);\n      return;\n    }\n\n    assert(this.state === PersistentStreamState.Initial, 'Already started');\n    this.listener = listener;\n    this.auth();\n  }\n\n  /**\n   * Stops the RPC. This call is idempotent and allowed regardless of the\n   * current isStarted state.\n   *\n   * When stop returns, isStarted and isOpen will both return false.\n   */\n  stop(): void {\n    if (this.isStarted()) {\n      this.close(PersistentStreamState.Stopped);\n    }\n  }\n\n  /**\n   * After an error the stream will usually back off on the next attempt to\n   * start it. If the error warrants an immediate restart of the stream, the\n   * sender can use this to indicate that the receiver should not back off.\n   *\n   * Each error will call the onClose function. That function can decide to\n   * inhibit backoff if required.\n   */\n  inhibitBackoff(): void {\n    assert(!this.isStarted(), 'Can only inhibit backoff in a stopped state');\n\n    this.state = PersistentStreamState.Initial;\n    this.backoff.reset();\n  }\n\n  /**\n   * Marks this stream as idle. If no further actions are performed on the\n   * stream for one minute, the stream will automatically close itself and\n   * notify the stream's onClose() handler with Status.OK. The stream will then\n   * be in a !isStarted() state, requiring the caller to start the stream again\n   * before further use.\n   *\n   * Only streams that are in state 'Open' can be marked idle, as all other\n   * states imply pending network operations.\n   */\n  markIdle(): void {\n    // Starts the idle time if we are in state 'Open' and are not yet already\n    // running a timer (in which case the previous idle timeout still applies).\n    if (this.isOpen() && this.inactivityTimerPromise === null) {\n      this.inactivityTimerPromise = this.queue.enqueueAfterDelay(\n        this.idleTimerId,\n        IDLE_TIMEOUT_MS,\n        () => this.handleIdleCloseTimer()\n      );\n    }\n  }\n\n  /** Sends a message to the underlying stream. */\n  protected sendRequest(msg: SendType): void {\n    this.cancelIdleCheck();\n    this.stream!.send(msg);\n  }\n\n  /** Called by the idle timer when the stream should close due to inactivity. */\n  private async handleIdleCloseTimer(): Promise<void> {\n    if (this.isOpen()) {\n      // When timing out an idle stream there's no reason to force the stream into backoff when\n      // it restarts so set the stream state to Initial instead of Error.\n      return this.close(PersistentStreamState.Initial);\n    }\n  }\n\n  /** Marks the stream as active again. */\n  private cancelIdleCheck() {\n    if (this.inactivityTimerPromise) {\n      this.inactivityTimerPromise.cancel();\n      this.inactivityTimerPromise = null;\n    }\n  }\n\n  /**\n   * Closes the stream and cleans up as necessary:\n   *\n   * * closes the underlying GRPC stream;\n   * * calls the onClose handler with the given 'error';\n   * * sets internal stream state to 'finalState';\n   * * adjusts the backoff timer based on the error\n   *\n   * A new stream can be opened by calling `start` unless `finalState` is set to\n   * `PersistentStreamState.Stopped`.\n   *\n   * @param finalState the intended state of the stream after closing.\n   * @param error the error the connection was closed with.\n   */\n  private async close(\n    finalState: PersistentStreamState,\n    error?: FirestoreError\n  ): Promise<void> {\n    assert(\n      finalState === PersistentStreamState.Error || isNullOrUndefined(error),\n      \"Can't provide an error when not in an error state.\"\n    );\n\n    this.cancelIdleCheck();\n\n    if (finalState !== PersistentStreamState.Error) {\n      // If this is an intentional close ensure we don't delay our next connection attempt.\n      this.backoff.reset();\n    } else if (error && error.code === Code.RESOURCE_EXHAUSTED) {\n      // Log the error. (Probably either 'quota exceeded' or 'max queue length reached'.)\n      log.error(error.toString());\n      log.error(\n        'Using maximum backoff delay to prevent overloading the backend.'\n      );\n      this.backoff.resetToMax();\n    }\n\n    // Clean up the underlying stream because we are no longer interested in events.\n    if (this.stream !== null) {\n      this.tearDown();\n      this.stream.close();\n      this.stream = null;\n    }\n\n    // This state must be assigned before calling onClose() to allow the callback to\n    // inhibit backoff or otherwise manipulate the state in its non-started state.\n    this.state = finalState;\n    const listener = this.listener!;\n\n    // Clear the listener to avoid bleeding of events from the underlying streams.\n    this.listener = null;\n\n    // If the caller explicitly requested a stream stop, don't notify them of a closing stream (it\n    // could trigger undesirable recovery logic, etc.).\n    if (finalState !== PersistentStreamState.Stopped) {\n      return listener.onClose(error);\n    }\n  }\n\n  /**\n   * Can be overridden to perform additional cleanup before the stream is closed.\n   * Calling super.tearDown() is not required.\n   */\n  protected tearDown(): void {}\n\n  /**\n   * Used by subclasses to start the concrete RPC and return the underlying\n   * connection stream.\n   */\n  protected abstract startRpc(\n    token: Token | null\n  ): Stream<SendType, ReceiveType>;\n\n  /**\n   * Called after the stream has received a message. The function will be\n   * called on the right queue and must return a Promise.\n   * @param message The message received from the stream.\n   */\n  protected abstract onMessage(message: ReceiveType): Promise<void>;\n\n  private auth(): void {\n    assert(\n      this.state === PersistentStreamState.Initial,\n      'Must be in initial state to auth'\n    );\n\n    this.state = PersistentStreamState.Auth;\n\n    this.credentialsProvider.getToken(/*forceRefresh=*/ false).then(\n      token => {\n        // Normally we'd have to schedule the callback on the AsyncQueue.\n        // However, the following calls are safe to be called outside the\n        // AsyncQueue since they don't chain asynchronous calls\n        this.startStream(token);\n      },\n      (error: Error) => {\n        this.queue.enqueue(async () => {\n          if (this.state !== PersistentStreamState.Stopped) {\n            // Stream can be stopped while waiting for authorization.\n            const rpcError = new FirestoreError(\n              Code.UNKNOWN,\n              'Fetching auth token failed: ' + error.message\n            );\n            return this.handleStreamClose(rpcError);\n          }\n        });\n      }\n    );\n  }\n\n  private startStream(token: Token | null): void {\n    if (this.state === PersistentStreamState.Stopped) {\n      // Stream can be stopped while waiting for authorization.\n      return;\n    }\n\n    assert(\n      this.state === PersistentStreamState.Auth,\n      'Trying to start stream in a non-auth state'\n    );\n    // Helper function to dispatch to AsyncQueue and make sure that any\n    // close will seem instantaneous and events are prevented from being\n    // raised after the close call\n    const dispatchIfStillActive = (\n      stream: Stream<SendType, ReceiveType>,\n      fn: () => Promise<void>\n    ) => {\n      this.queue.enqueue(async () => {\n        // Only raise events if the stream instance has not changed\n        if (this.stream === stream) {\n          return fn();\n        }\n      });\n    };\n\n    // Only start stream if listener has not changed\n    if (this.listener !== null) {\n      const currentStream = this.startRpc(token);\n      this.stream = currentStream;\n      this.stream.onOpen(() => {\n        dispatchIfStillActive(currentStream, () => {\n          assert(\n            this.state === PersistentStreamState.Auth,\n            'Expected stream to be in state auth, but was ' + this.state\n          );\n          this.state = PersistentStreamState.Open;\n          return this.listener!.onOpen();\n        });\n      });\n      this.stream.onClose((error: FirestoreError) => {\n        dispatchIfStillActive(currentStream, () => {\n          return this.handleStreamClose(error);\n        });\n      });\n      this.stream.onMessage((msg: ReceiveType) => {\n        dispatchIfStillActive(currentStream, () => {\n          return this.onMessage(msg);\n        });\n      });\n    }\n  }\n\n  private performBackoff(listener: ListenerType): void {\n    assert(\n      this.state === PersistentStreamState.Error,\n      'Should only perform backoff in an error case'\n    );\n    this.state = PersistentStreamState.Backoff;\n\n    this.backoff.backoffAndRun(async () => {\n      if (this.state === PersistentStreamState.Stopped) {\n        // Stream can be stopped while waiting for backoff to complete.\n        return;\n      }\n\n      this.state = PersistentStreamState.Initial;\n      this.start(listener);\n      assert(this.isStarted(), 'PersistentStream should have started');\n    });\n  }\n\n  private handleStreamClose(error?: FirestoreError): Promise<void> {\n    assert(this.isStarted(), \"Can't handle server close on non-started stream\");\n    log.debug(LOG_TAG, `close with error: ${error}`);\n\n    this.stream = null;\n\n    // In theory the stream could close cleanly, however, in our current model\n    // we never expect this to happen because if we stop a stream ourselves,\n    // this callback will never be called. To prevent cases where we retry\n    // without a backoff accidentally, we set the stream to error in all cases.\n    return this.close(PersistentStreamState.Error, error);\n  }\n}\n\n/** Listener for the PersistentWatchStream */\nexport interface WatchStreamListener extends PersistentStreamListener {\n  /**\n   * Called on a watchChange. The snapshot parameter will be MIN if the watch\n   * change did not have a snapshot associated with it.\n   */\n  onWatchChange: (\n    watchChange: WatchChange,\n    snapshot: SnapshotVersion\n  ) => Promise<void>;\n}\n\n/**\n * A PersistentStream that implements the Listen RPC.\n *\n * Once the Listen stream has called the openHandler, any number of listen and\n * unlisten calls calls can be sent to control what changes will be sent from\n * the server for ListenResponses.\n */\nexport class PersistentListenStream extends PersistentStream<\n  api.ListenRequest,\n  api.ListenResponse,\n  WatchStreamListener\n> {\n  constructor(\n    queue: AsyncQueue,\n    connection: Connection,\n    credentials: CredentialsProvider,\n    private serializer: JsonProtoSerializer\n  ) {\n    super(\n      queue,\n      TimerId.ListenStreamConnectionBackoff,\n      TimerId.ListenStreamIdle,\n      connection,\n      credentials\n    );\n  }\n\n  protected startRpc(\n    token: Token | null\n  ): Stream<api.ListenRequest, api.ListenResponse> {\n    return this.connection.openStream<api.ListenRequest, api.ListenResponse>(\n      'Listen',\n      token\n    );\n  }\n\n  protected onMessage(watchChangeProto: api.ListenResponse): Promise<void> {\n    // A successful response means the stream is healthy\n    this.backoff.reset();\n\n    const watchChange = this.serializer.fromWatchChange(watchChangeProto);\n    const snapshot = this.serializer.versionFromListenResponse(\n      watchChangeProto\n    );\n    return this.listener!.onWatchChange(watchChange, snapshot);\n  }\n\n  /**\n   * Registers interest in the results of the given query. If the query\n   * includes a resumeToken it will be included in the request. Results that\n   * affect the query will be streamed back as WatchChange messages that\n   * reference the targetId.\n   */\n  watch(queryData: QueryData): void {\n    const request: ListenRequest = {};\n    request.database = this.serializer.encodedDatabaseId;\n    request.addTarget = this.serializer.toTarget(queryData);\n\n    const labels = this.serializer.toListenRequestLabels(queryData);\n    if (labels) {\n      request.labels = labels;\n    }\n\n    this.sendRequest(request);\n  }\n\n  /**\n   * Unregisters interest in the results of the query associated with the\n   * given targetId.\n   */\n  unwatch(targetId: TargetId): void {\n    const request: ListenRequest = {};\n    request.database = this.serializer.encodedDatabaseId;\n    request.removeTarget = targetId;\n    this.sendRequest(request);\n  }\n}\n\n/** Listener for the PersistentWriteStream */\nexport interface WriteStreamListener extends PersistentStreamListener {\n  /**\n   * Called by the PersistentWriteStream upon a successful handshake response\n   * from the server, which is the receiver's cue to send any pending writes.\n   */\n  onHandshakeComplete: () => Promise<void>;\n\n  /**\n   * Called by the PersistentWriteStream upon receiving a StreamingWriteResponse\n   * from the server that contains a mutation result.\n   */\n  onMutationResult: (\n    commitVersion: SnapshotVersion,\n    results: MutationResult[]\n  ) => Promise<void>;\n}\n\n/**\n * A Stream that implements the Write RPC.\n *\n * The Write RPC requires the caller to maintain special streamToken\n * state in between calls, to help the server understand which responses the\n * client has processed by the time the next request is made. Every response\n * will contain a streamToken; this value must be passed to the next\n * request.\n *\n * After calling start() on this stream, the next request must be a handshake,\n * containing whatever streamToken is on hand. Once a response to this\n * request is received, all pending mutations may be submitted. When\n * submitting multiple batches of mutations at the same time, it's\n * okay to use the same streamToken for the calls to writeMutations.\n *\n * TODO(b/33271235): Use proto types\n */\nexport class PersistentWriteStream extends PersistentStream<\n  api.WriteRequest,\n  api.WriteResponse,\n  WriteStreamListener\n> {\n  private handshakeComplete_ = false;\n\n  constructor(\n    queue: AsyncQueue,\n    connection: Connection,\n    credentials: CredentialsProvider,\n    private serializer: JsonProtoSerializer\n  ) {\n    super(\n      queue,\n      TimerId.WriteStreamConnectionBackoff,\n      TimerId.WriteStreamIdle,\n      connection,\n      credentials\n    );\n  }\n\n  /**\n   * The last received stream token from the server, used to acknowledge which\n   * responses the client has processed. Stream tokens are opaque checkpoint\n   * markers whose only real value is their inclusion in the next request.\n   *\n   * PersistentWriteStream manages propagating this value from responses to the\n   * next request.\n   */\n  lastStreamToken: ProtoByteString;\n\n  /**\n   * Tracks whether or not a handshake has been successfully exchanged and\n   * the stream is ready to accept mutations.\n   */\n  get handshakeComplete(): boolean {\n    return this.handshakeComplete_;\n  }\n\n  // Override of PersistentStream.start\n  start(listener: WriteStreamListener): void {\n    this.handshakeComplete_ = false;\n    super.start(listener);\n  }\n\n  protected tearDown() {\n    if (this.handshakeComplete_) {\n      this.writeMutations([]);\n    }\n  }\n\n  protected startRpc(\n    token: Token | null\n  ): Stream<api.WriteRequest, api.WriteResponse> {\n    return this.connection.openStream<api.WriteRequest, api.WriteResponse>(\n      'Write',\n      token\n    );\n  }\n\n  protected onMessage(responseProto: api.WriteResponse): Promise<void> {\n    // Always capture the last stream token.\n    assert(\n      !!responseProto.streamToken,\n      'Got a write response without a stream token'\n    );\n    this.lastStreamToken = responseProto.streamToken!;\n\n    if (!this.handshakeComplete_) {\n      // The first response is always the handshake response\n      assert(\n        !responseProto.writeResults || responseProto.writeResults.length === 0,\n        'Got mutation results for handshake'\n      );\n      this.handshakeComplete_ = true;\n      return this.listener!.onHandshakeComplete();\n    } else {\n      // A successful first write response means the stream is healthy,\n      // Note, that we could consider a successful handshake healthy, however,\n      // the write itself might be causing an error we want to back off from.\n      this.backoff.reset();\n\n      const results = this.serializer.fromWriteResults(\n        responseProto.writeResults\n      );\n      const commitVersion = this.serializer.fromVersion(\n        responseProto.commitTime!\n      );\n      return this.listener!.onMutationResult(commitVersion, results);\n    }\n  }\n\n  /**\n   * Sends an initial streamToken to the server, performing the handshake\n   * required to make the StreamingWrite RPC work. Subsequent\n   * calls should wait until onHandshakeComplete was called.\n   */\n  writeHandshake(): void {\n    assert(this.isOpen(), 'Writing handshake requires an opened stream');\n    assert(!this.handshakeComplete_, 'Handshake already completed');\n    // TODO(dimond): Support stream resumption. We intentionally do not set the\n    // stream token on the handshake, ignoring any stream token we might have.\n    const request: WriteRequest = {};\n    request.database = this.serializer.encodedDatabaseId;\n    this.sendRequest(request);\n  }\n\n  /** Sends a group of mutations to the Firestore backend to apply. */\n  writeMutations(mutations: Mutation[]): void {\n    assert(this.isOpen(), 'Writing mutations requires an opened stream');\n    assert(\n      this.handshakeComplete_,\n      'Handshake must be complete before writing mutations'\n    );\n    assert(\n      this.lastStreamToken.length > 0,\n      'Trying to write mutation without a token'\n    );\n\n    const request: WriteRequest = {\n      // Protos are typed with string, but we support UInt8Array on Node\n      // tslint:disable-next-line:no-any\n      streamToken: this.lastStreamToken as any,\n      writes: mutations.map(mutation => this.serializer.toMutation(mutation))\n    };\n\n    this.sendRequest(request);\n  }\n}\n"]}