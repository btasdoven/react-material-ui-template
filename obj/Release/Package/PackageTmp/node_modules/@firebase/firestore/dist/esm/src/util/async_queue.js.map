{"version":3,"sources":["../src/util/async_queue.ts"],"names":[],"mappings":"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","file":"async_queue.js","sourcesContent":["/**\n * Copyright 2017 Google Inc.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\nimport { assert, fail } from './assert';\nimport * as log from './log';\nimport { AnyJs } from './misc';\nimport { Deferred, CancelablePromise } from './promise';\nimport { Code, FirestoreError } from './error';\n\n// tslint:disable-next-line:no-any Accept any return type from setTimeout().\ntype TimerHandle = any;\n\n/**\n * Wellknown \"timer\" IDs used when scheduling delayed operations on the\n * AsyncQueue. These IDs can then be used from tests to check for the presence\n * of operations or to run them early.\n *\n * The string values are used when encoding these timer IDs in JSON spec tests.\n */\nexport enum TimerId {\n  /** All can be used with runDelayedOperationsEarly() to run all timers. */\n  All = 'all',\n\n  /**\n   * The following 4 timers are used in persistent_stream.ts for the listen and\n   * write streams. The \"Idle\" timer is used to close the stream due to\n   * inactivity. The \"ConnectionBackoff\" timer is used to restart a stream once\n   * the appropriate backoff delay has elapsed.\n   */\n  ListenStreamIdle = 'listen_stream_idle',\n  ListenStreamConnectionBackoff = 'listen_stream_connection_backoff',\n  WriteStreamIdle = 'write_stream_idle',\n  WriteStreamConnectionBackoff = 'write_stream_connection_backoff',\n\n  /**\n   * A timer used in online_state_tracker.ts to transition from\n   * OnlineState.Unknown to Offline after a set timeout, rather than waiting\n   * indefinitely for success or failure.\n   */\n  OnlineStateTimeout = 'online_state_timeout'\n}\n\n/**\n * Represents an operation scheduled to be run in the future on an AsyncQueue.\n *\n * It is created via DelayedOperation.createAndSchedule().\n *\n * Supports cancellation (via cancel()) and early execution (via skipDelay()).\n */\nclass DelayedOperation<T> implements CancelablePromise<T> {\n  // handle for use with clearTimeout(), or null if the operation has been\n  // executed or canceled already.\n  private timerHandle: TimerHandle | null;\n\n  private readonly deferred = new Deferred<T>();\n\n  private constructor(\n    private readonly asyncQueue: AsyncQueue,\n    readonly timerId: TimerId,\n    readonly targetTimeMs: number,\n    private readonly op: () => Promise<T>,\n    private readonly removalCallback: (op: DelayedOperation<T>) => void\n  ) {\n    // It's normal for the deferred promise to be canceled (due to cancellation)\n    // and so we attach a dummy catch callback to avoid\n    // 'UnhandledPromiseRejectionWarning' log spam.\n    this.deferred.promise.catch(err => {});\n  }\n\n  /**\n   * Creates and returns a DelayedOperation that has been scheduled to be\n   * executed on the provided asyncQueue after the provided delayMs.\n   *\n   * @param asyncQueue The queue to schedule the operation on.\n   * @param id A Timer ID identifying the type of operation this is.\n   * @param delayMs The delay (ms) before the operation should be scheduled.\n   * @param op The operation to run.\n   * @param removalCallback A callback to be called synchronously once the\n   *   operation is executed or canceled, notifying the AsyncQueue to remove it\n   *   from its delayedOperations list.\n   *   PORTING NOTE: This exists to prevent making removeDelayedOperation() and\n   *   the DelayedOperation class public.\n   */\n  static createAndSchedule<T>(\n    asyncQueue: AsyncQueue,\n    timerId: TimerId,\n    delayMs: number,\n    op: () => Promise<T>,\n    removalCallback: (op: DelayedOperation<T>) => void\n  ): DelayedOperation<T> {\n    const targetTime = Date.now() + delayMs;\n    const delayedOp = new DelayedOperation(\n      asyncQueue,\n      timerId,\n      targetTime,\n      op,\n      removalCallback\n    );\n    delayedOp.start(delayMs);\n    return delayedOp;\n  }\n\n  /**\n   * Starts the timer. This is called immediately after construction by\n   * createAndSchedule().\n   */\n  private start(delayMs: number): void {\n    this.timerHandle = setTimeout(() => this.handleDelayElapsed(), delayMs);\n  }\n\n  /**\n   * Queues the operation to run immediately (if it hasn't already been run or\n   * canceled).\n   */\n  skipDelay(): void {\n    return this.handleDelayElapsed();\n  }\n\n  /**\n   * Cancels the operation if it hasn't already been executed or canceled. The\n   * promise will be rejected.\n   *\n   * As long as the operation has not yet been run, calling cancel() provides a\n   * guarantee that the operation will not be run.\n   */\n  cancel(reason?: string): void {\n    if (this.timerHandle !== null) {\n      this.clearTimeout();\n      this.deferred.reject(\n        new FirestoreError(\n          Code.CANCELLED,\n          'Operation cancelled' + (reason ? ': ' + reason : '')\n        )\n      );\n    }\n  }\n\n  // Promise implementation.\n  readonly [Symbol.toStringTag]: 'Promise';\n  then = this.deferred.promise.then.bind(this.deferred.promise);\n  catch = this.deferred.promise.catch.bind(this.deferred.promise);\n\n  private handleDelayElapsed(): void {\n    this.asyncQueue.enqueue(() => {\n      if (this.timerHandle !== null) {\n        this.clearTimeout();\n        return this.op().then(result => {\n          return this.deferred.resolve(result);\n        });\n      } else {\n        return Promise.resolve();\n      }\n    });\n  }\n\n  private clearTimeout() {\n    if (this.timerHandle !== null) {\n      this.removalCallback(this);\n      clearTimeout(this.timerHandle);\n      this.timerHandle = null;\n    }\n  }\n}\n\nexport class AsyncQueue {\n  // The last promise in the queue.\n  private tail: Promise<AnyJs | void> = Promise.resolve();\n\n  // Operations scheduled to be queued in the future. Operations are\n  // automatically removed after they are run or canceled.\n  private delayedOperations: Array<DelayedOperation<AnyJs>> = [];\n\n  // visible for testing\n  failure: Error;\n\n  // Flag set while there's an outstanding AsyncQueue operation, used for\n  // assertion sanity-checks.\n  private operationInProgress = false;\n\n  /**\n   * Adds a new operation to the queue. Returns a promise that will be resolved\n   * when the promise returned by the new operation is (with its value).\n   */\n  enqueue<T>(op: () => Promise<T>): Promise<T> {\n    this.verifyNotFailed();\n    const newTail = this.tail.then(() => {\n      this.operationInProgress = true;\n      return op()\n        .catch(error => {\n          this.failure = error;\n          this.operationInProgress = false;\n          const message = error.stack || error.message || '';\n          log.error('INTERNAL UNHANDLED ERROR: ', message);\n\n          // Escape the promise chain and throw the error globally so that\n          // e.g. any global crash reporting library detects and reports it.\n          // (but not for simulated errors in our tests since this breaks mocha)\n          if (message.indexOf('Firestore Test Simulated Error') < 0) {\n            setTimeout(() => {\n              throw error;\n            }, 0);\n          }\n\n          // Re-throw the error so that this.tail becomes a rejected Promise and\n          // all further attempts to chain (via .then) will just short-circuit\n          // and return the rejected Promise.\n          throw error;\n        })\n        .then(result => {\n          this.operationInProgress = false;\n          return result;\n        });\n    });\n    this.tail = newTail;\n    return newTail;\n  }\n\n  /**\n   * Schedules an operation to be queued on the AsyncQueue once the specified\n   * `delayMs` has elapsed. The returned CancelablePromise can be used to cancel\n   * the operation prior to its running.\n   */\n  enqueueAfterDelay<T>(\n    timerId: TimerId,\n    delayMs: number,\n    op: () => Promise<T>\n  ): CancelablePromise<T> {\n    this.verifyNotFailed();\n\n    // While not necessarily harmful, we currently don't expect to have multiple\n    // ops with the same timer id in the queue, so defensively reject them.\n    assert(\n      !this.containsDelayedOperation(timerId),\n      `Attempted to schedule multiple operations with timer id ${timerId}.`\n    );\n\n    const delayedOp = DelayedOperation.createAndSchedule(\n      this,\n      timerId,\n      delayMs,\n      op,\n      op => this.removeDelayedOperation(op)\n    );\n    this.delayedOperations.push(delayedOp);\n\n    return delayedOp;\n  }\n\n  private verifyNotFailed(): void {\n    if (this.failure) {\n      fail(\n        'AsyncQueue is already failed: ' +\n          (this.failure.stack || this.failure.message)\n      );\n    }\n  }\n\n  /**\n   * Verifies there's an operation currently in-progress on the AsyncQueue.\n   * Unfortunately we can't verify that the running code is in the promise chain\n   * of that operation, so this isn't a foolproof check, but it should be enough\n   * to catch some bugs.\n   */\n  verifyOperationInProgress(): void {\n    assert(\n      this.operationInProgress,\n      'verifyOpInProgress() called when no op in progress on this queue.'\n    );\n  }\n\n  /**\n   * Waits until all currently queued tasks are finished executing. Delayed\n   * operations are not run.\n   */\n  drain(): Promise<void> {\n    return this.enqueue(() => Promise.resolve());\n  }\n\n  /**\n   * For Tests: Determine if a delayed operation with a particular TimerId\n   * exists.\n   */\n  containsDelayedOperation(timerId: TimerId): boolean {\n    return this.delayedOperations.findIndex(op => op.timerId === timerId) >= 0;\n  }\n\n  /**\n   * For Tests: Runs some or all delayed operations early.\n   *\n   * @param lastTimerId Delayed operations up to and including this TimerId will\n   *  be drained. Throws if no such operation exists. Pass TimerId.All to run\n   *  all delayed operations.\n   * @returns a Promise that resolves once all operations have been run.\n   */\n  runDelayedOperationsEarly(lastTimerId: TimerId): Promise<void> {\n    // Note that draining may generate more delayed ops, so we do that first.\n    return this.drain().then(() => {\n      assert(\n        lastTimerId === TimerId.All ||\n          this.containsDelayedOperation(lastTimerId),\n        `Attempted to drain to missing operation ${lastTimerId}`\n      );\n\n      // Run ops in the same order they'd run if they ran naturally.\n      this.delayedOperations.sort((a, b) => a.targetTimeMs - b.targetTimeMs);\n\n      for (const op of this.delayedOperations) {\n        op.skipDelay();\n        if (lastTimerId !== TimerId.All && op.timerId === lastTimerId) {\n          break;\n        }\n      }\n\n      return this.drain();\n    });\n  }\n\n  /** Called once a DelayedOperation is run or canceled. */\n  private removeDelayedOperation<T>(op: DelayedOperation<T>) {\n    // NOTE: indexOf / slice are O(n), but delayedOperations is expected to be small.\n    const index = this.delayedOperations.indexOf(op);\n    assert(index >= 0, 'Delayed operation not found.');\n    this.delayedOperations.splice(index, 1);\n  }\n}\n"]}