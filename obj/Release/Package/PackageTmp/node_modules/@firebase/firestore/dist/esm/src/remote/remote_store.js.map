{"version":3,"sources":["../src/remote/remote_store.ts"],"names":[],"mappings":"AAAA;;;;;;;;;;;;;;GAcG;;AAGH,OAAO,EAAE,eAAe,EAAE,MAAM,0BAA0B,CAAC;AAC3D,OAAO,EAAE,WAAW,EAAE,MAAM,qBAAqB,CAAC;AAClD,OAAO,EAAW,WAAW,EAAY,MAAM,eAAe,CAAC;AAE/D,OAAO,EAAE,SAAS,EAAE,YAAY,EAAE,MAAM,qBAAqB,CAAC;AAC9D,OAAO,EAAE,UAAU,EAAE,MAAM,mBAAmB,CAAC;AAC/C,OAAO,EAAE,WAAW,EAAE,MAAM,uBAAuB,CAAC;AAEpD,OAAO,EACL,eAAe,EAEf,mBAAmB,EACpB,MAAM,yBAAyB,CAAC;AACjC,OAAO,EAAE,eAAe,EAAE,MAAM,sBAAsB,CAAC;AACvD,OAAO,EAAE,MAAM,EAAE,MAAM,gBAAgB,CAAC;AACxC,OAAO,EAAE,IAAI,EAAkB,MAAM,eAAe,CAAC;AACrD,OAAO,KAAK,GAAG,MAAM,aAAa,CAAC;AACnC,OAAO,KAAK,QAAQ,MAAM,aAAa,CAAC;AAQxC,OAAO,EAAE,YAAY,EAAE,aAAa,EAAE,MAAM,gBAAgB,CAAC;AAE7D,OAAO,EAAE,gBAAgB,EAAE,MAAM,aAAa,CAAC;AAC/C,OAAO,EAEL,qBAAqB,EACrB,iBAAiB,EACjB,sBAAsB,EACvB,MAAM,gBAAgB,CAAC;AACxB,OAAO,EAAE,kBAAkB,EAAE,MAAM,wBAAwB,CAAC;AAG5D,IAAM,OAAO,GAAG,aAAa,CAAC;AAE9B,oDAAoD;AACpD,IAAM,kBAAkB,GAAG,EAAE,CAAC;AAE9B;;;;;;;;;;;;;;;;;;GAkBG;AACH;IAsCE;IACE;;;OAGG;IACK,UAAsB;IAC9B,8DAA8D;IACtD,SAAoB,EAC5B,UAAsB,EACtB,kBAAsD;QAJ9C,eAAU,GAAV,UAAU,CAAY;QAEtB,cAAS,GAAT,SAAS,CAAW;QA5CtB,kBAAa,GAAoB,EAAE,CAAC;QACpC,kBAAa,GAAY,eAAe,CAAC;QAEjD;;;;;;;;WAQG;QACK,kBAAa,GAAsC,EAAE,CAAC;QAE9D;;;;;;;;;;;;;WAaG;QACK,2BAAsB,GAAmC,EAAE,CAAC;QAE5D,4BAAuB,GAAkB,EAAE,CAAC;QAE5C,gBAAW,GAA2B,IAAI,CAAC;QAC3C,gBAAW,GAA0B,IAAI,CAAC;QAehD,IAAI,CAAC,kBAAkB,GAAG,IAAI,kBAAkB,CAC9C,UAAU,EACV,kBAAkB,CACnB,CAAC;IACJ,CAAC;IAKD;;;OAGG;IACH,2BAAK,GAAL;QACE,MAAM,CAAC,IAAI,CAAC,aAAa,EAAE,CAAC;IAC9B,CAAC;IAEO,sCAAgB,GAAxB;QACE,MAAM,CACJ,CAAC,IAAI,CAAC,WAAW,IAAI,IAAI,CAAC,KAAK,CAAC,IAAI,CAAC,WAAW,IAAI,IAAI,CAAC,EACzD,6DAA6D,CAC9D,CAAC;QACF,MAAM,CAAC,IAAI,CAAC,WAAW,IAAI,IAAI,CAAC;IAClC,CAAC;IAED,0CAA0C;IAC1C,mCAAa,GAAb;QAAA,iBAqBC;QApBC,EAAE,CAAC,CAAC,IAAI,CAAC,gBAAgB,EAAE,CAAC,CAAC,CAAC;YAC5B,MAAM,CAAC,OAAO,CAAC,OAAO,EAAE,CAAC;QAC3B,CAAC;QAED,yDAAyD;QACzD,IAAI,CAAC,WAAW,GAAG,IAAI,CAAC,SAAS,CAAC,wBAAwB,EAAE,CAAC;QAC7D,IAAI,CAAC,WAAW,GAAG,IAAI,CAAC,SAAS,CAAC,wBAAwB,EAAE,CAAC;QAE7D,sDAAsD;QACtD,MAAM,CAAC,IAAI,CAAC,UAAU,CAAC,kBAAkB,EAAE,CAAC,IAAI,CAAC,UAAA,KAAK;YACpD,KAAI,CAAC,WAAW,CAAC,eAAe,GAAG,KAAK,CAAC;YAEzC,EAAE,CAAC,CAAC,KAAI,CAAC,sBAAsB,EAAE,CAAC,CAAC,CAAC;gBAClC,KAAI,CAAC,gBAAgB,EAAE,CAAC;YAC1B,CAAC;YAAC,IAAI,CAAC,CAAC;gBACN,KAAI,CAAC,kBAAkB,CAAC,GAAG,CAAC,WAAW,CAAC,OAAO,CAAC,CAAC;YACnD,CAAC;YAED,MAAM,CAAC,KAAI,CAAC,iBAAiB,EAAE,CAAC,CAAC,kCAAkC;QACrE,CAAC,CAAC,CAAC;IACL,CAAC;IAED;;;OAGG;IACG,oCAAc,GAApB;;;gBACE,IAAI,CAAC,sBAAsB,EAAE,CAAC;gBAC9B,mEAAmE;gBACnE,IAAI,CAAC,kBAAkB,CAAC,GAAG,CAAC,WAAW,CAAC,OAAO,CAAC,CAAC;;;;KAClD;IAED;;OAEG;IACK,4CAAsB,GAA9B;QACE,EAAE,CAAC,CAAC,IAAI,CAAC,gBAAgB,EAAE,CAAC,CAAC,CAAC;YAC5B,4FAA4F;YAC5F,UAAU;YACV,IAAI,CAAC,WAAW,CAAC,IAAI,EAAE,CAAC;YACxB,IAAI,CAAC,WAAW,CAAC,IAAI,EAAE,CAAC;YAExB,IAAI,CAAC,uBAAuB,EAAE,CAAC;YAC/B,IAAI,CAAC,uBAAuB,EAAE,CAAC;YAE/B,IAAI,CAAC,WAAW,GAAG,IAAI,CAAC;YACxB,IAAI,CAAC,WAAW,GAAG,IAAI,CAAC;QAC1B,CAAC;IACH,CAAC;IAED,8BAAQ,GAAR;QACE,GAAG,CAAC,KAAK,CAAC,OAAO,EAAE,4BAA4B,CAAC,CAAC;QACjD,IAAI,CAAC,sBAAsB,EAAE,CAAC;QAC9B,4EAA4E;QAC5E,6DAA6D;QAC7D,IAAI,CAAC,kBAAkB,CAAC,GAAG,CAAC,WAAW,CAAC,OAAO,CAAC,CAAC;QACjD,MAAM,CAAC,OAAO,CAAC,OAAO,EAAE,CAAC;IAC3B,CAAC;IAED,2EAA2E;IAC3E,4BAAM,GAAN,UAAO,SAAoB;QACzB,MAAM,CACJ,CAAC,QAAQ,CAAC,QAAQ,CAAC,IAAI,CAAC,aAAa,EAAE,SAAS,CAAC,QAAQ,CAAC,EAC1D,wCAAwC,CACzC,CAAC;QACF,gEAAgE;QAChE,IAAI,CAAC,aAAa,CAAC,SAAS,CAAC,QAAQ,CAAC,GAAG,SAAS,CAAC;QAEnD,EAAE,CAAC,CAAC,IAAI,CAAC,sBAAsB,EAAE,CAAC,CAAC,CAAC;YAClC,+CAA+C;YAC/C,IAAI,CAAC,gBAAgB,EAAE,CAAC;QAC1B,CAAC;QAAC,IAAI,CAAC,EAAE,CAAC,CAAC,IAAI,CAAC,gBAAgB,EAAE,IAAI,IAAI,CAAC,WAAW,CAAC,MAAM,EAAE,CAAC,CAAC,CAAC;YAChE,IAAI,CAAC,gBAAgB,CAAC,SAAS,CAAC,CAAC;QACnC,CAAC;IACH,CAAC;IAED,qCAAqC;IACrC,8BAAQ,GAAR,UAAS,QAAkB;QACzB,MAAM,CACJ,QAAQ,CAAC,QAAQ,CAAC,IAAI,CAAC,aAAa,EAAE,QAAQ,CAAC,EAC/C,6CAA6C,CAC9C,CAAC;QACF,OAAO,IAAI,CAAC,aAAa,CAAC,QAAQ,CAAC,CAAC;QACpC,EAAE,CAAC,CAAC,IAAI,CAAC,gBAAgB,EAAE,IAAI,IAAI,CAAC,WAAW,CAAC,MAAM,EAAE,CAAC,CAAC,CAAC;YACzD,IAAI,CAAC,kBAAkB,CAAC,QAAQ,CAAC,CAAC;YAClC,EAAE,CAAC,CAAC,QAAQ,CAAC,OAAO,CAAC,IAAI,CAAC,aAAa,CAAC,CAAC,CAAC,CAAC;gBACzC,IAAI,CAAC,WAAW,CAAC,QAAQ,EAAE,CAAC;YAC9B,CAAC;QACH,CAAC;IACH,CAAC;IAED;;;OAGG;IACK,sCAAgB,GAAxB,UAAyB,SAAoB;QAC3C,IAAI,CAAC,0BAA0B,CAAC,SAAS,CAAC,QAAQ,CAAC,CAAC;QACpD,IAAI,CAAC,WAAW,CAAC,KAAK,CAAC,SAAS,CAAC,CAAC;IACpC,CAAC;IAED;;;;OAIG;IACK,wCAAkB,GAA1B,UAA2B,QAAkB;QAC3C,IAAI,CAAC,0BAA0B,CAAC,QAAQ,CAAC,CAAC;QAC1C,IAAI,CAAC,WAAW,CAAC,OAAO,CAAC,QAAQ,CAAC,CAAC;IACrC,CAAC;IAED;;;OAGG;IACK,gDAA0B,GAAlC,UAAmC,QAAkB;QACnD,uEAAuE;QACvE,IAAI,CAAC,sBAAsB,CAAC,QAAQ,CAAC;YACnC,CAAC,IAAI,CAAC,sBAAsB,CAAC,QAAQ,CAAC,IAAI,CAAC,CAAC,GAAG,CAAC,CAAC;IACrD,CAAC;IAEO,sCAAgB,GAAxB;QACE,MAAM,CACJ,IAAI,CAAC,sBAAsB,EAAE,EAC7B,mEAAmE,CACpE,CAAC;QACF,IAAI,CAAC,WAAW,CAAC,KAAK,CAAC;YACrB,MAAM,EAAE,IAAI,CAAC,iBAAiB,CAAC,IAAI,CAAC,IAAI,CAAC;YACzC,OAAO,EAAE,IAAI,CAAC,kBAAkB,CAAC,IAAI,CAAC,IAAI,CAAC;YAC3C,aAAa,EAAE,IAAI,CAAC,mBAAmB,CAAC,IAAI,CAAC,IAAI,CAAC;SACnD,CAAC,CAAC;QAEH,IAAI,CAAC,kBAAkB,CAAC,sBAAsB,EAAE,CAAC;IACnD,CAAC;IAED;;;OAGG;IACK,4CAAsB,GAA9B;QACE,MAAM,CAAC,CACL,IAAI,CAAC,gBAAgB,EAAE;YACvB,CAAC,IAAI,CAAC,WAAW,CAAC,SAAS,EAAE;YAC7B,CAAC,QAAQ,CAAC,OAAO,CAAC,IAAI,CAAC,aAAa,CAAC,CACtC,CAAC;IACJ,CAAC;IAEO,6CAAuB,GAA/B;QACE,0EAA0E;QAC1E,4EAA4E;QAC5E,qEAAqE;QACrE,8CAA8C;QAC9C,IAAI,CAAC,uBAAuB,GAAG,EAAE,CAAC;QAClC,IAAI,CAAC,sBAAsB,GAAG,EAAE,CAAC;IACnC,CAAC;IAEa,uCAAiB,GAA/B;;;;gBACE,4EAA4E;gBAC5E,qBAAqB;gBACrB,QAAQ,CAAC,aAAa,CAAC,IAAI,CAAC,aAAa,EAAE,UAAC,QAAQ,EAAE,SAAS;oBAC7D,KAAI,CAAC,gBAAgB,CAAC,SAAS,CAAC,CAAC;gBACnC,CAAC,CAAC,CAAC;;;;KACJ;IAEa,wCAAkB,GAAhC,UACE,KAA4B;;;gBAE5B,MAAM,CACJ,IAAI,CAAC,gBAAgB,EAAE,EACvB,wEAAwE,CACzE,CAAC;gBAEF,IAAI,CAAC,uBAAuB,EAAE,CAAC;gBAC/B,IAAI,CAAC,kBAAkB,CAAC,wBAAwB,EAAE,CAAC;gBAEnD,+CAA+C;gBAC/C,EAAE,CAAC,CAAC,IAAI,CAAC,sBAAsB,EAAE,CAAC,CAAC,CAAC;oBAClC,IAAI,CAAC,gBAAgB,EAAE,CAAC;gBAC1B,CAAC;gBAAC,IAAI,CAAC,CAAC;oBACN,uEAAuE;oBACvE,wEAAwE;oBACxE,+BAA+B;oBAC/B,IAAI,CAAC,kBAAkB,CAAC,GAAG,CAAC,WAAW,CAAC,OAAO,CAAC,CAAC;gBACnD,CAAC;;;;KACF;IAEa,yCAAmB,GAAjC,UACE,WAAwB,EACxB,eAAgC;;;;gBAEhC,mEAAmE;gBACnE,IAAI,CAAC,kBAAkB,CAAC,GAAG,CAAC,WAAW,CAAC,MAAM,CAAC,CAAC;gBAEhD,EAAE,CAAC,CACD,WAAW,YAAY,iBAAiB;oBACxC,WAAW,CAAC,KAAK,KAAK,sBAAsB,CAAC,OAAO;oBACpD,WAAW,CAAC,KACd,CAAC,CAAC,CAAC;oBACD,uEAAuE;oBACvE,kBAAkB;oBAClB,MAAM,gBAAC,IAAI,CAAC,iBAAiB,CAAC,WAAW,CAAC,EAAC;gBAC7C,CAAC;gBACD,gEAAgE;gBAChE,yEAAyE;gBACzE,8DAA8D;gBAC9D,IAAI,CAAC,uBAAuB,CAAC,IAAI,CAAC,WAAW,CAAC,CAAC;gBAC/C,EAAE,CAAC,CACD,CAAC,eAAe,CAAC,OAAO,CAAC,eAAe,CAAC,GAAG,CAAC;oBAC7C,eAAe,CAAC,SAAS,CACvB,IAAI,CAAC,UAAU,CAAC,4BAA4B,EAAE,CAC/C,IAAI,CACP,CAAC,CAAC,CAAC;oBACK,OAAO,GAAG,IAAI,CAAC,uBAAuB,CAAC;oBAC7C,IAAI,CAAC,uBAAuB,GAAG,EAAE,CAAC;oBAClC,MAAM,gBAAC,IAAI,CAAC,sBAAsB,CAAC,eAAe,EAAE,OAAO,CAAC,EAAC;gBAC/D,CAAC;;;;KACF;IAED;;;;OAIG;IACK,4CAAsB,GAA9B,UACE,eAAgC,EAChC,OAAsB;QAFxB,iBAyHC;QArHC,IAAM,UAAU,GAAG,IAAI,qBAAqB,CAC1C,eAAe,EACf,IAAI,CAAC,aAAa,EAClB,IAAI,CAAC,sBAAsB,CAC5B,CAAC;QACF,UAAU,CAAC,UAAU,CAAC,OAAO,CAAC,CAAC;QAC/B,IAAM,WAAW,GAAG,UAAU,CAAC,iBAAiB,EAAE,CAAC;QACnD,kDAAkD;QAClD,IAAI,CAAC,sBAAsB,GAAG,UAAU,CAAC,sBAAsB,CAAC;QAEhE,IAAM,QAAQ,GAAyB,EAAE,CAAC;QAC1C,4DAA4D;QAC5D,QAAQ,CAAC,aAAa,CACpB,UAAU,CAAC,gBAAgB,EAC3B,UAAC,QAAkB,EAAE,MAAuB;YAC1C,IAAM,SAAS,GAAG,KAAI,CAAC,aAAa,CAAC,QAAQ,CAAC,CAAC;YAC/C,EAAE,CAAC,CAAC,CAAC,SAAS,CAAC,CAAC,CAAC;gBACf,oDAAoD;gBACpD,MAAM,CAAC;YACT,CAAC;YACD,IAAM,KAAK,GAAG,SAAS,CAAC,KAAK,CAAC;YAC9B,EAAE,CAAC,CAAC,KAAK,CAAC,eAAe,EAAE,CAAC,CAAC,CAAC;gBAC5B,EAAE,CAAC,CAAC,MAAM,CAAC,KAAK,KAAK,CAAC,CAAC,CAAC,CAAC;oBACvB,4DAA4D;oBAC5D,gEAAgE;oBAChE,gEAAgE;oBAChE,6DAA6D;oBAC7D,uDAAuD;oBACvD,sDAAsD;oBACtD,IAAM,GAAG,GAAG,IAAI,WAAW,CAAC,KAAK,CAAC,IAAI,CAAC,CAAC;oBACxC,IAAM,UAAU,GAAG,IAAI,UAAU,CAAC,GAAG,EAAE,eAAe,CAAC,CAAC;oBACxD,WAAW,CAAC,iBAAiB,CAAC,UAAU,CAAC,CAAC;gBAC5C,CAAC;gBAAC,IAAI,CAAC,CAAC;oBACN,MAAM,CACJ,MAAM,CAAC,KAAK,KAAK,CAAC,EAClB,+CAA+C,GAAG,MAAM,CAAC,KAAK,CAC/D,CAAC;gBACJ,CAAC;YACH,CAAC;YAAC,IAAI,CAAC,CAAC;gBACN,wBAAwB;gBACxB,IAAM,OAAO,GAAG,KAAI,CAAC,UAAU;qBAC5B,kBAAkB,CAAC,QAAQ,CAAC;qBAC5B,IAAI,CAAC,UAAA,aAAa;oBACjB,EAAE,CAAC,CAAC,WAAW,CAAC,aAAa,CAAC,QAAQ,CAAC,CAAC,CAAC,CAAC;wBACxC,IAAM,OAAO,GAAG,WAAW,CAAC,aAAa,CAAC,QAAQ,CAAC,CAAC,OAAO,CAAC;wBAC5D,EAAE,CAAC,CAAC,OAAO,KAAK,IAAI,CAAC,CAAC,CAAC;4BACrB,EAAE,CAAC,CAAC,OAAO,YAAY,aAAa,CAAC,CAAC,CAAC;gCACrC,aAAa,GAAG,OAAO,CAAC,aAAa,CAAC,aAAa,CAAC,CAAC;4BACvD,CAAC;4BAAC,IAAI,CAAC,CAAC;gCACN,MAAM,CACJ,OAAO,YAAY,YAAY,EAC/B,kEAAkE;oCAChE,OAAO,CACV,CAAC;gCACF,aAAa,GAAG,OAAO,CAAC,SAAS,CAAC;4BACpC,CAAC;wBACH,CAAC;oBACH,CAAC;oBAED,EAAE,CAAC,CAAC,aAAa,CAAC,IAAI,KAAK,MAAM,CAAC,KAAK,CAAC,CAAC,CAAC;wBACxC,gDAAgD;wBAEhD,yDAAyD;wBACzD,WAAW,CAAC,6BAA6B,CAAC,QAAQ,CAAC,CAAC;wBAEpD,yDAAyD;wBACzD,wBAAwB;wBACxB,IAAM,YAAY,GAAG,IAAI,SAAS,CAChC,KAAK,EACL,QAAQ,EACR,SAAS,CAAC,OAAO,CAClB,CAAC;wBACF,KAAI,CAAC,aAAa,CAAC,QAAQ,CAAC,GAAG,YAAY,CAAC;wBAE5C,kDAAkD;wBAClD,0DAA0D;wBAC1D,gCAAgC;wBAChC,0DAA0D;wBAC1D,KAAI,CAAC,kBAAkB,CAAC,QAAQ,CAAC,CAAC;wBAElC,4DAA4D;wBAC5D,qDAAqD;wBACrD,qDAAqD;wBACrD,yDAAyD;wBACzD,qDAAqD;wBACrD,IAAM,gBAAgB,GAAG,IAAI,SAAS,CACpC,KAAK,EACL,QAAQ,EACR,YAAY,CAAC,uBAAuB,CACrC,CAAC;wBACF,KAAI,CAAC,gBAAgB,CAAC,gBAAgB,CAAC,CAAC;oBAC1C,CAAC;gBACH,CAAC,CAAC,CAAC;gBACL,QAAQ,CAAC,IAAI,CAAC,OAAO,CAAC,CAAC;YACzB,CAAC;QACH,CAAC,CACF,CAAC;QAEF,MAAM,CAAC,OAAO,CAAC,GAAG,CAAC,QAAQ,CAAC,CAAC,IAAI,CAAC;YAChC,6DAA6D;YAC7D,oEAAoE;YACpE,QAAQ,CAAC,aAAa,CAAC,WAAW,CAAC,aAAa,EAAE,UAAC,QAAQ,EAAE,MAAM;gBACjE,EAAE,CAAC,CAAC,MAAM,CAAC,WAAW,CAAC,MAAM,GAAG,CAAC,CAAC,CAAC,CAAC;oBAClC,IAAM,SAAS,GAAG,KAAI,CAAC,aAAa,CAAC,QAAQ,CAAC,CAAC;oBAC/C,oDAAoD;oBACpD,EAAE,CAAC,CAAC,SAAS,CAAC,CAAC,CAAC;wBACd,KAAI,CAAC,aAAa,CAAC,QAAQ,CAAC,GAAG,SAAS,CAAC,MAAM,CAAC;4BAC9C,WAAW,EAAE,MAAM,CAAC,WAAW;4BAC/B,eAAe,EAAE,MAAM,CAAC,eAAe;yBACxC,CAAC,CAAC;oBACL,CAAC;gBACH,CAAC;YACH,CAAC,CAAC,CAAC;YAEH,8BAA8B;YAC9B,MAAM,CAAC,KAAI,CAAC,UAAU,CAAC,gBAAgB,CAAC,WAAW,CAAC,CAAC;QACvD,CAAC,CAAC,CAAC;IACL,CAAC;IAED,mCAAmC;IAC3B,uCAAiB,GAAzB,UAA0B,WAA8B;QAAxD,iBAcC;QAbC,MAAM,CAAC,CAAC,CAAC,WAAW,CAAC,KAAK,EAAE,uCAAuC,CAAC,CAAC;QACrE,IAAM,KAAK,GAAG,WAAW,CAAC,KAAM,CAAC;QACjC,IAAI,YAAY,GAAG,OAAO,CAAC,OAAO,EAAE,CAAC;QACrC,WAAW,CAAC,SAAS,CAAC,OAAO,CAAC,UAAA,QAAQ;YACpC,YAAY,GAAG,YAAY,CAAC,IAAI,CAAC;;oBAC/B,oDAAoD;oBACpD,EAAE,CAAC,CAAC,QAAQ,CAAC,QAAQ,CAAC,IAAI,CAAC,aAAa,EAAE,QAAQ,CAAC,CAAC,CAAC,CAAC;wBACpD,OAAO,IAAI,CAAC,aAAa,CAAC,QAAQ,CAAC,CAAC;wBACpC,MAAM,gBAAC,IAAI,CAAC,UAAU,CAAC,YAAY,CAAC,QAAQ,EAAE,KAAK,CAAC,EAAC;oBACvD,CAAC;;;iBACF,CAAC,CAAC;QACL,CAAC,CAAC,CAAC;QACH,MAAM,CAAC,YAAY,CAAC;IACtB,CAAC;IAED,6CAAuB,GAAvB;QACE,IAAI,CAAC,aAAa,GAAG,eAAe,CAAC;QACrC,GAAG,CAAC,KAAK,CACP,OAAO,EACP,6BAA6B;YAC3B,IAAI,CAAC,aAAa,CAAC,MAAM;YACzB,iBAAiB,CACpB,CAAC;QACF,IAAI,CAAC,aAAa,GAAG,EAAE,CAAC;IAC1B,CAAC;IAED;;;OAGG;IACG,uCAAiB,GAAvB;;;;gBACE,EAAE,CAAC,CAAC,IAAI,CAAC,iBAAiB,EAAE,CAAC,CAAC,CAAC;oBAC7B,MAAM,gBAAC,IAAI,CAAC,UAAU;6BACnB,iBAAiB,CAAC,IAAI,CAAC,aAAa,CAAC;6BACrC,IAAI,CAAC,UAAA,KAAK;4BACT,EAAE,CAAC,CAAC,KAAK,KAAK,IAAI,CAAC,CAAC,CAAC;gCACnB,EAAE,CAAC,CAAC,KAAI,CAAC,aAAa,CAAC,MAAM,KAAK,CAAC,CAAC,CAAC,CAAC;oCACpC,KAAI,CAAC,WAAW,CAAC,QAAQ,EAAE,CAAC;gCAC9B,CAAC;4BACH,CAAC;4BAAC,IAAI,CAAC,CAAC;gCACN,KAAI,CAAC,MAAM,CAAC,KAAK,CAAC,CAAC;gCACnB,MAAM,CAAC,KAAI,CAAC,iBAAiB,EAAE,CAAC;4BAClC,CAAC;wBACH,CAAC,CAAC,EAAC;gBACP,CAAC;;;;KACF;IAED;;;;;;;;;OASG;IACH,uCAAiB,GAAjB;QACE,MAAM,CAAC,CACL,IAAI,CAAC,gBAAgB,EAAE,IAAI,IAAI,CAAC,aAAa,CAAC,MAAM,GAAG,kBAAkB,CAC1E,CAAC;IACJ,CAAC;IAED,cAAc;IACd,uCAAiB,GAAjB;QACE,MAAM,CAAC,IAAI,CAAC,aAAa,CAAC,MAAM,CAAC;IACnC,CAAC;IAED;;;;OAIG;IACK,4BAAM,GAAd,UAAe,KAAoB;QACjC,MAAM,CACJ,IAAI,CAAC,iBAAiB,EAAE,EACxB,6CAA6C,CAC9C,CAAC;QACF,IAAI,CAAC,aAAa,GAAG,KAAK,CAAC,OAAO,CAAC;QAEnC,IAAI,CAAC,aAAa,CAAC,IAAI,CAAC,KAAK,CAAC,CAAC;QAE/B,EAAE,CAAC,CAAC,IAAI,CAAC,sBAAsB,EAAE,CAAC,CAAC,CAAC;YAClC,IAAI,CAAC,gBAAgB,EAAE,CAAC;QAC1B,CAAC;QAAC,IAAI,CAAC,EAAE,CAAC,CAAC,IAAI,CAAC,gBAAgB,EAAE,IAAI,IAAI,CAAC,WAAW,CAAC,iBAAiB,CAAC,CAAC,CAAC;YACzE,IAAI,CAAC,WAAW,CAAC,cAAc,CAAC,KAAK,CAAC,SAAS,CAAC,CAAC;QACnD,CAAC;IACH,CAAC;IAEO,4CAAsB,GAA9B;QACE,MAAM,CAAC,CACL,IAAI,CAAC,gBAAgB,EAAE;YACvB,CAAC,IAAI,CAAC,WAAW,CAAC,SAAS,EAAE;YAC7B,IAAI,CAAC,aAAa,CAAC,MAAM,GAAG,CAAC,CAC9B,CAAC;IACJ,CAAC;IAEO,sCAAgB,GAAxB;QACE,MAAM,CACJ,IAAI,CAAC,sBAAsB,EAAE,EAC7B,mEAAmE,CACpE,CAAC;QACF,IAAI,CAAC,WAAW,CAAC,KAAK,CAAC;YACrB,MAAM,EAAE,IAAI,CAAC,iBAAiB,CAAC,IAAI,CAAC,IAAI,CAAC;YACzC,OAAO,EAAE,IAAI,CAAC,kBAAkB,CAAC,IAAI,CAAC,IAAI,CAAC;YAC3C,mBAAmB,EAAE,IAAI,CAAC,wBAAwB,CAAC,IAAI,CAAC,IAAI,CAAC;YAC7D,gBAAgB,EAAE,IAAI,CAAC,gBAAgB,CAAC,IAAI,CAAC,IAAI,CAAC;SACnD,CAAC,CAAC;IACL,CAAC;IAEa,uCAAiB,GAA/B;;;gBACE,IAAI,CAAC,WAAW,CAAC,cAAc,EAAE,CAAC;;;;KACnC;IAEO,8CAAwB,GAAhC;QAAA,iBAsBC;QArBC,2BAA2B;QAC3B,MAAM,CAAC,IAAI,CAAC,UAAU;aACnB,kBAAkB,CAAC,IAAI,CAAC,WAAW,CAAC,eAAe,CAAC;aACpD,IAAI,CAAC;YACJ,4BAA4B;YAC5B,EAAE;YACF,gEAAgE;YAChE,kEAAkE;YAClE,iEAAiE;YACjE,yDAAyD;YACzD,EAAE;YACF,kEAAkE;YAClE,kEAAkE;YAClE,8DAA8D;YAC9D,+DAA+D;YAC/D,gEAAgE;YAChE,mCAAmC;YACnC,GAAG,CAAC,CAAgB,UAAkB,EAAlB,KAAA,KAAI,CAAC,aAAa,EAAlB,cAAkB,EAAlB,IAAkB;gBAAjC,IAAM,KAAK,SAAA;gBACd,KAAI,CAAC,WAAW,CAAC,cAAc,CAAC,KAAK,CAAC,SAAS,CAAC,CAAC;aAClD;QACH,CAAC,CAAC,CAAC;IACP,CAAC;IAEO,sCAAgB,GAAxB,UACE,aAA8B,EAC9B,OAAyB;QAF3B,iBAsBC;QAlBC,mEAAmE;QACnE,yCAAyC;QACzC,MAAM,CACJ,IAAI,CAAC,aAAa,CAAC,MAAM,GAAG,CAAC,EAC7B,qCAAqC,CACtC,CAAC;QACF,IAAM,KAAK,GAAG,IAAI,CAAC,aAAa,CAAC,KAAK,EAAG,CAAC;QAC1C,IAAM,OAAO,GAAG,mBAAmB,CAAC,IAAI,CACtC,KAAK,EACL,aAAa,EACb,OAAO,EACP,IAAI,CAAC,WAAW,CAAC,eAAe,CACjC,CAAC;QACF,MAAM,CAAC,IAAI,CAAC,UAAU,CAAC,oBAAoB,CAAC,OAAO,CAAC,CAAC,IAAI,CAAC;YACxD,kEAAkE;YAClE,qBAAqB;YACrB,MAAM,CAAC,KAAI,CAAC,iBAAiB,EAAE,CAAC;QAClC,CAAC,CAAC,CAAC;IACL,CAAC;IAEa,wCAAkB,GAAhC,UAAiC,KAAsB;;;;;gBACrD,MAAM,CACJ,IAAI,CAAC,gBAAgB,EAAE,EACvB,wEAAwE,CACzE,CAAC;gBAEF,4EAA4E;gBAC5E,4BAA4B;gBAC5B,EAAE,CAAC,CAAC,KAAK,IAAI,IAAI,CAAC,aAAa,CAAC,MAAM,GAAG,CAAC,CAAC,CAAC,CAAC;oBAC3C,MAAM,CACJ,CAAC,CAAC,KAAK,EACP,sEAAsE,CACvE,CAAC;oBAEE,aAAa,SAAe,CAAC;oBACjC,EAAE,CAAC,CAAC,IAAI,CAAC,WAAW,CAAC,iBAAiB,CAAC,CAAC,CAAC;wBACvC,uCAAuC;wBACvC,aAAa,GAAG,IAAI,CAAC,gBAAgB,CAAC,KAAM,CAAC,CAAC;oBAChD,CAAC;oBAAC,IAAI,CAAC,CAAC;wBACN,gEAAgE;wBAChE,iEAAiE;wBACjE,yCAAyC;wBACzC,aAAa,GAAG,IAAI,CAAC,oBAAoB,CAAC,KAAM,CAAC,CAAC;oBACpD,CAAC;oBAED,MAAM,gBAAC,aAAa,CAAC,IAAI,CAAC;4BACxB,kEAAkE;4BAClE,6BAA6B;4BAC7B,EAAE,CAAC,CAAC,KAAI,CAAC,sBAAsB,EAAE,CAAC,CAAC,CAAC;gCAClC,KAAI,CAAC,gBAAgB,EAAE,CAAC;4BAC1B,CAAC;wBACH,CAAC,CAAC,EAAC;gBACL,CAAC;;;;KAEF;IAEa,0CAAoB,GAAlC,UAAmC,KAAqB;;;gBACtD,iEAAiE;gBACjE,0DAA0D;gBAC1D,EAAE,CAAC,CAAC,gBAAgB,CAAC,KAAK,CAAC,IAAI,CAAC,IAAI,KAAK,CAAC,IAAI,KAAK,IAAI,CAAC,OAAO,CAAC,CAAC,CAAC;oBAChE,GAAG,CAAC,KAAK,CACP,OAAO,EACP,wEAAwE,EACxE,IAAI,CAAC,WAAW,CAAC,eAAe,CACjC,CAAC;oBACF,IAAI,CAAC,WAAW,CAAC,eAAe,GAAG,eAAe,EAAE,CAAC;oBAErD,MAAM,gBAAC,IAAI,CAAC,UAAU,CAAC,kBAAkB,CAAC,eAAe,EAAE,CAAC,EAAC;gBAC/D,CAAC;gBAAC,IAAI,CAAC,CAAC;oBACN,oEAAoE;oBACpE,uCAAuC;gBACzC,CAAC;;;;KACF;IAEa,sCAAgB,GAA9B,UAA+B,KAAqB;;;;;gBAClD,EAAE,CAAC,CAAC,gBAAgB,CAAC,KAAK,CAAC,IAAI,CAAC,CAAC,CAAC,CAAC;oBAG3B,KAAK,GAAG,IAAI,CAAC,aAAa,CAAC,KAAK,EAAG,CAAC;oBAE1C,oEAAoE;oBACpE,qEAAqE;oBACrE,WAAW;oBACX,IAAI,CAAC,WAAW,CAAC,cAAc,EAAE,CAAC;oBAElC,MAAM,gBAAC,IAAI,CAAC,UAAU;6BACnB,iBAAiB,CAAC,KAAK,CAAC,OAAO,EAAE,KAAK,CAAC;6BACvC,IAAI,CAAC;4BACJ,0DAA0D;4BAC1D,6BAA6B;4BAC7B,MAAM,CAAC,KAAI,CAAC,iBAAiB,EAAE,CAAC;wBAClC,CAAC,CAAC,EAAC;gBACP,CAAC;gBAAC,IAAI,CAAC,CAAC;oBACN,qDAAqD;gBACvD,CAAC;;;;KACF;IAED,uCAAiB,GAAjB;QACE,MAAM,CAAC,IAAI,WAAW,CAAC,IAAI,CAAC,SAAS,CAAC,CAAC;IACzC,CAAC;IAED,sCAAgB,GAAhB,UAAiB,IAAU;QACzB,GAAG,CAAC,KAAK,CAAC,OAAO,EAAE,kCAAkC,EAAE,IAAI,CAAC,GAAG,CAAC,CAAC;QAEjE,kEAAkE;QAClE,6BAA6B;QAC7B,EAAE,CAAC,CAAC,IAAI,CAAC,gBAAgB,EAAE,CAAC,CAAC,CAAC;YAC5B,0FAA0F;YAC1F,yFAAyF;YACzF,kCAAkC;YAClC,IAAI,CAAC,sBAAsB,EAAE,CAAC;YAC9B,IAAI,CAAC,kBAAkB,CAAC,GAAG,CAAC,WAAW,CAAC,OAAO,CAAC,CAAC;YACjD,MAAM,CAAC,IAAI,CAAC,aAAa,EAAE,CAAC;QAC9B,CAAC;IACH,CAAC;IACH,kBAAC;AAAD,CAxqBA,AAwqBC,IAAA","file":"remote_store.js","sourcesContent":["/**\n * Copyright 2017 Google Inc.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\nimport { User } from '../auth/user';\nimport { SnapshotVersion } from '../core/snapshot_version';\nimport { Transaction } from '../core/transaction';\nimport { BatchId, OnlineState, TargetId } from '../core/types';\nimport { LocalStore } from '../local/local_store';\nimport { QueryData, QueryPurpose } from '../local/query_data';\nimport { NoDocument } from '../model/document';\nimport { DocumentKey } from '../model/document_key';\nimport { MutationResult } from '../model/mutation';\nimport {\n  BATCHID_UNKNOWN,\n  MutationBatch,\n  MutationBatchResult\n} from '../model/mutation_batch';\nimport { emptyByteString } from '../platform/platform';\nimport { assert } from '../util/assert';\nimport { Code, FirestoreError } from '../util/error';\nimport * as log from '../util/log';\nimport * as objUtils from '../util/obj';\n\nimport { Datastore } from './datastore';\nimport { ExistenceFilter } from './existence_filter';\nimport {\n  PersistentListenStream,\n  PersistentWriteStream\n} from './persistent_stream';\nimport { ResetMapping, UpdateMapping } from './remote_event';\nimport { RemoteSyncer } from './remote_syncer';\nimport { isPermanentError } from './rpc_error';\nimport {\n  WatchChange,\n  WatchChangeAggregator,\n  WatchTargetChange,\n  WatchTargetChangeState\n} from './watch_change';\nimport { OnlineStateTracker } from './online_state_tracker';\nimport { AsyncQueue } from '../util/async_queue';\n\nconst LOG_TAG = 'RemoteStore';\n\n// TODO(b/35853402): Negotiate this with the stream.\nconst MAX_PENDING_WRITES = 10;\n\n/**\n * RemoteStore - An interface to remotely stored data, basically providing a\n * wrapper around the Datastore that is more reliable for the rest of the\n * system.\n *\n * RemoteStore is responsible for maintaining the connection to the server.\n * - maintaining a list of active listens.\n * - reconnecting when the connection is dropped.\n * - resuming all the active listens on reconnect.\n *\n * RemoteStore handles all incoming events from the Datastore.\n * - listening to the watch stream and repackaging the events as RemoteEvents\n * - notifying SyncEngine of any changes to the active listens.\n *\n * RemoteStore takes writes from other components and handles them reliably.\n * - pulling pending mutations from LocalStore and sending them to Datastore.\n * - retrying mutations that failed because of network problems.\n * - acking mutations to the SyncEngine once they are accepted or rejected.\n */\nexport class RemoteStore {\n  private pendingWrites: MutationBatch[] = [];\n  private lastBatchSeen: BatchId = BATCHID_UNKNOWN;\n\n  /**\n   * A mapping of watched targets that the client cares about tracking and the\n   * user has explicitly called a 'listen' for this target.\n   *\n   * These targets may or may not have been sent to or acknowledged by the\n   * server. On re-establishing the listen stream, these targets should be sent\n   * to the server. The targets removed with unlistens are removed eagerly\n   * without waiting for confirmation from the listen stream.\n   */\n  private listenTargets: { [targetId: number]: QueryData } = {};\n\n  /**\n   * A mapping of targetId to pending acks needed.\n   *\n   * If a targetId is present in this map, then we're waiting for watch to\n   * acknowledge a removal or addition of the target. If a target is not in this\n   * mapping, and it's in the listenTargets map, then we consider the target to\n   * be active.\n   *\n   * We increment the count here every time we issue a request over the stream\n   * to watch or unwatch. We then decrement the count every time we get a target\n   * added or target removed message from the server. Once the count is equal to\n   * 0 we know that the client and server are in the same state (once this state\n   * is reached the targetId is removed from the map to free the memory).\n   */\n  private pendingTargetResponses: { [targetId: number]: number } = {};\n\n  private accumulatedWatchChanges: WatchChange[] = [];\n\n  private watchStream: PersistentListenStream = null;\n  private writeStream: PersistentWriteStream = null;\n\n  private onlineStateTracker: OnlineStateTracker;\n\n  constructor(\n    /**\n     * The local store, used to fill the write pipeline with outbound\n     * mutations and resolve existence filter mismatches.\n     */\n    private localStore: LocalStore,\n    /** The client-side proxy for interacting with the backend. */\n    private datastore: Datastore,\n    asyncQueue: AsyncQueue,\n    onlineStateHandler: (onlineState: OnlineState) => void\n  ) {\n    this.onlineStateTracker = new OnlineStateTracker(\n      asyncQueue,\n      onlineStateHandler\n    );\n  }\n\n  /** SyncEngine to notify of watch and write events. */\n  syncEngine: RemoteSyncer;\n\n  /**\n   * Starts up the remote store, creating streams, restoring state from\n   * LocalStore, etc.\n   */\n  start(): Promise<void> {\n    return this.enableNetwork();\n  }\n\n  private isNetworkEnabled(): boolean {\n    assert(\n      (this.watchStream == null) === (this.writeStream == null),\n      'WatchStream and WriteStream should both be null or non-null'\n    );\n    return this.watchStream != null;\n  }\n\n  /** Re-enables the network. Idempotent. */\n  enableNetwork(): Promise<void> {\n    if (this.isNetworkEnabled()) {\n      return Promise.resolve();\n    }\n\n    // Create new streams (but note they're not started yet).\n    this.watchStream = this.datastore.newPersistentWatchStream();\n    this.writeStream = this.datastore.newPersistentWriteStream();\n\n    // Load any saved stream token from persistent storage\n    return this.localStore.getLastStreamToken().then(token => {\n      this.writeStream.lastStreamToken = token;\n\n      if (this.shouldStartWatchStream()) {\n        this.startWatchStream();\n      } else {\n        this.onlineStateTracker.set(OnlineState.Unknown);\n      }\n\n      return this.fillWritePipeline(); // This may start the writeStream.\n    });\n  }\n\n  /**\n   * Temporarily disables the network. The network can be re-enabled using\n   * enableNetwork().\n   */\n  async disableNetwork(): Promise<void> {\n    this.disableNetworkInternal();\n    // Set the OnlineState to Offline so get()s return from cache, etc.\n    this.onlineStateTracker.set(OnlineState.Offline);\n  }\n\n  /**\n   * Disables the network, if it is currently enabled.\n   */\n  private disableNetworkInternal(): void {\n    if (this.isNetworkEnabled()) {\n      // NOTE: We're guaranteed not to get any further events from these streams (not even a close\n      // event).\n      this.watchStream.stop();\n      this.writeStream.stop();\n\n      this.cleanUpWatchStreamState();\n      this.cleanUpWriteStreamState();\n\n      this.writeStream = null;\n      this.watchStream = null;\n    }\n  }\n\n  shutdown(): Promise<void> {\n    log.debug(LOG_TAG, 'RemoteStore shutting down.');\n    this.disableNetworkInternal();\n    // Set the OnlineState to Unknown (rather than Offline) to avoid potentially\n    // triggering spurious listener events with cached data, etc.\n    this.onlineStateTracker.set(OnlineState.Unknown);\n    return Promise.resolve();\n  }\n\n  /** Starts new listen for the given query. Uses resume token if provided */\n  listen(queryData: QueryData): void {\n    assert(\n      !objUtils.contains(this.listenTargets, queryData.targetId),\n      'listen called with duplicate targetId!'\n    );\n    // Mark this as something the client is currently listening for.\n    this.listenTargets[queryData.targetId] = queryData;\n\n    if (this.shouldStartWatchStream()) {\n      // The listen will be sent in onWatchStreamOpen\n      this.startWatchStream();\n    } else if (this.isNetworkEnabled() && this.watchStream.isOpen()) {\n      this.sendWatchRequest(queryData);\n    }\n  }\n\n  /** Removes the listen from server */\n  unlisten(targetId: TargetId): void {\n    assert(\n      objUtils.contains(this.listenTargets, targetId),\n      'unlisten called without assigned target ID!'\n    );\n    delete this.listenTargets[targetId];\n    if (this.isNetworkEnabled() && this.watchStream.isOpen()) {\n      this.sendUnwatchRequest(targetId);\n      if (objUtils.isEmpty(this.listenTargets)) {\n        this.watchStream.markIdle();\n      }\n    }\n  }\n\n  /**\n   * We need to increment the the expected number of pending responses we're due\n   * from watch so we wait for the ack to process any messages from this target.\n   */\n  private sendWatchRequest(queryData: QueryData): void {\n    this.recordPendingTargetRequest(queryData.targetId);\n    this.watchStream.watch(queryData);\n  }\n\n  /**\n   * We need to increment the expected number of pending responses we're due\n   * from watch so we wait for the removal on the server before we process any\n   * messages from this target.\n   */\n  private sendUnwatchRequest(targetId: TargetId): void {\n    this.recordPendingTargetRequest(targetId);\n    this.watchStream.unwatch(targetId);\n  }\n\n  /**\n   * Increment the mapping of how many acks are needed from watch before we can\n   * consider the server to be 'in-sync' with the client's active targets.\n   */\n  private recordPendingTargetRequest(targetId: TargetId): void {\n    // For each request we get we need to record we need a response for it.\n    this.pendingTargetResponses[targetId] =\n      (this.pendingTargetResponses[targetId] || 0) + 1;\n  }\n\n  private startWatchStream(): void {\n    assert(\n      this.shouldStartWatchStream(),\n      'startWriteStream() called when shouldStartWatchStream() is false.'\n    );\n    this.watchStream.start({\n      onOpen: this.onWatchStreamOpen.bind(this),\n      onClose: this.onWatchStreamClose.bind(this),\n      onWatchChange: this.onWatchStreamChange.bind(this)\n    });\n\n    this.onlineStateTracker.handleWatchStreamStart();\n  }\n\n  /**\n   * Returns whether the watch stream should be started because it's necessary\n   * and has not yet been started.\n   */\n  private shouldStartWatchStream(): boolean {\n    return (\n      this.isNetworkEnabled() &&\n      !this.watchStream.isStarted() &&\n      !objUtils.isEmpty(this.listenTargets)\n    );\n  }\n\n  private cleanUpWatchStreamState(): void {\n    // If the connection is closed then we'll never get a snapshot version for\n    // the accumulated changes and so we'll never be able to complete the batch.\n    // When we start up again the server is going to resend these changes\n    // anyway, so just toss the accumulated state.\n    this.accumulatedWatchChanges = [];\n    this.pendingTargetResponses = {};\n  }\n\n  private async onWatchStreamOpen(): Promise<void> {\n    // TODO(b/35852690): close the stream again (with some timeout?) if no watch\n    // targets are active\n    objUtils.forEachNumber(this.listenTargets, (targetId, queryData) => {\n      this.sendWatchRequest(queryData);\n    });\n  }\n\n  private async onWatchStreamClose(\n    error: FirestoreError | null\n  ): Promise<void> {\n    assert(\n      this.isNetworkEnabled(),\n      'onWatchStreamClose() should only be called when the network is enabled'\n    );\n\n    this.cleanUpWatchStreamState();\n    this.onlineStateTracker.handleWatchStreamFailure();\n\n    // If there was an error, retry the connection.\n    if (this.shouldStartWatchStream()) {\n      this.startWatchStream();\n    } else {\n      // No need to restart watch stream because there are no active targets.\n      // The online state is set to unknown because there is no active attempt\n      // at establishing a connection\n      this.onlineStateTracker.set(OnlineState.Unknown);\n    }\n  }\n\n  private async onWatchStreamChange(\n    watchChange: WatchChange,\n    snapshotVersion: SnapshotVersion\n  ): Promise<void> {\n    // Mark the client as online since we got a message from the server\n    this.onlineStateTracker.set(OnlineState.Online);\n\n    if (\n      watchChange instanceof WatchTargetChange &&\n      watchChange.state === WatchTargetChangeState.Removed &&\n      watchChange.cause\n    ) {\n      // There was an error on a target, don't wait for a consistent snapshot\n      // to raise events\n      return this.handleTargetError(watchChange);\n    }\n    // Accumulate watch changes but don't process them if there's no\n    // snapshotVersion or it's older than a previous snapshot we've processed\n    // (can happen after we resume a target using a resume token).\n    this.accumulatedWatchChanges.push(watchChange);\n    if (\n      !snapshotVersion.isEqual(SnapshotVersion.MIN) &&\n      snapshotVersion.compareTo(\n        this.localStore.getLastRemoteSnapshotVersion()\n      ) >= 0\n    ) {\n      const changes = this.accumulatedWatchChanges;\n      this.accumulatedWatchChanges = [];\n      return this.handleWatchChangeBatch(snapshotVersion, changes);\n    }\n  }\n\n  /**\n   * Takes a batch of changes from the Datastore, repackages them as a\n   * RemoteEvent, and passes that on to the listener, which is typically the\n   * SyncEngine.\n   */\n  private handleWatchChangeBatch(\n    snapshotVersion: SnapshotVersion,\n    changes: WatchChange[]\n  ): Promise<void> {\n    const aggregator = new WatchChangeAggregator(\n      snapshotVersion,\n      this.listenTargets,\n      this.pendingTargetResponses\n    );\n    aggregator.addChanges(changes);\n    const remoteEvent = aggregator.createRemoteEvent();\n    // Get the new response counts from the aggregator\n    this.pendingTargetResponses = aggregator.pendingTargetResponses;\n\n    const promises: Array<Promise<void>> = [];\n    // Handle existence filters and existence filter mismatches.\n    objUtils.forEachNumber(\n      aggregator.existenceFilters,\n      (targetId: TargetId, filter: ExistenceFilter) => {\n        const queryData = this.listenTargets[targetId];\n        if (!queryData) {\n          // A watched target might have been removed already.\n          return;\n        }\n        const query = queryData.query;\n        if (query.isDocumentQuery()) {\n          if (filter.count === 0) {\n            // The existence filter told us the document does not exist.\n            // We need to deduce that this document does not exist and apply\n            // a deleted document to our updates. Without applying a deleted\n            // document there might be another query that will raise this\n            // document as part of a snapshot until it is resolved,\n            // essentially exposing inconsistency between queries.\n            const key = new DocumentKey(query.path);\n            const deletedDoc = new NoDocument(key, snapshotVersion);\n            remoteEvent.addDocumentUpdate(deletedDoc);\n          } else {\n            assert(\n              filter.count === 1,\n              'Single document existence filter with count: ' + filter.count\n            );\n          }\n        } else {\n          // Not a document query.\n          const promise = this.localStore\n            .remoteDocumentKeys(targetId)\n            .then(trackedRemote => {\n              if (remoteEvent.targetChanges[targetId]) {\n                const mapping = remoteEvent.targetChanges[targetId].mapping;\n                if (mapping !== null) {\n                  if (mapping instanceof UpdateMapping) {\n                    trackedRemote = mapping.applyToKeySet(trackedRemote);\n                  } else {\n                    assert(\n                      mapping instanceof ResetMapping,\n                      'Expected either reset or update mapping but got something else: ' +\n                        mapping\n                    );\n                    trackedRemote = mapping.documents;\n                  }\n                }\n              }\n\n              if (trackedRemote.size !== filter.count) {\n                // Existence filter mismatch, resetting mapping.\n\n                // Make sure the mismatch is exposed in the remote event.\n                remoteEvent.handleExistenceFilterMismatch(targetId);\n\n                // Clear the resume token for the query, since we're in a\n                // known mismatch state.\n                const newQueryData = new QueryData(\n                  query,\n                  targetId,\n                  queryData.purpose\n                );\n                this.listenTargets[targetId] = newQueryData;\n\n                // Cause a hard reset by unwatching and rewatching\n                // immediately, but deliberately don't send a resume token\n                // so that we get a full update.\n                // Make sure we expect that this acks are going to happen.\n                this.sendUnwatchRequest(targetId);\n\n                // Mark the query we send as being on behalf of an existence\n                // filter mismatch, but don't actually retain that in\n                // listenTargets. This ensures that we flag the first\n                // re-listen this way without impacting future listens of\n                // this target (that might happen e.g. on reconnect).\n                const requestQueryData = new QueryData(\n                  query,\n                  targetId,\n                  QueryPurpose.ExistenceFilterMismatch\n                );\n                this.sendWatchRequest(requestQueryData);\n              }\n            });\n          promises.push(promise);\n        }\n      }\n    );\n\n    return Promise.all(promises).then(() => {\n      // Update in-memory resume tokens. LocalStore will update the\n      // persistent view of these when applying the completed RemoteEvent.\n      objUtils.forEachNumber(remoteEvent.targetChanges, (targetId, change) => {\n        if (change.resumeToken.length > 0) {\n          const queryData = this.listenTargets[targetId];\n          // A watched target might have been removed already.\n          if (queryData) {\n            this.listenTargets[targetId] = queryData.update({\n              resumeToken: change.resumeToken,\n              snapshotVersion: change.snapshotVersion\n            });\n          }\n        }\n      });\n\n      // Finally handle remote event\n      return this.syncEngine.applyRemoteEvent(remoteEvent);\n    });\n  }\n\n  /** Handles an error on a target */\n  private handleTargetError(watchChange: WatchTargetChange): Promise<void> {\n    assert(!!watchChange.cause, 'Handling target error without a cause');\n    const error = watchChange.cause!;\n    let promiseChain = Promise.resolve();\n    watchChange.targetIds.forEach(targetId => {\n      promiseChain = promiseChain.then(async () => {\n        // A watched target might have been removed already.\n        if (objUtils.contains(this.listenTargets, targetId)) {\n          delete this.listenTargets[targetId];\n          return this.syncEngine.rejectListen(targetId, error);\n        }\n      });\n    });\n    return promiseChain;\n  }\n\n  cleanUpWriteStreamState() {\n    this.lastBatchSeen = BATCHID_UNKNOWN;\n    log.debug(\n      LOG_TAG,\n      'Stopping write stream with ' +\n        this.pendingWrites.length +\n        ' pending writes'\n    );\n    this.pendingWrites = [];\n  }\n\n  /**\n   * Notifies that there are new mutations to process in the queue. This is\n   * typically called by SyncEngine after it has sent mutations to LocalStore.\n   */\n  async fillWritePipeline(): Promise<void> {\n    if (this.canWriteMutations()) {\n      return this.localStore\n        .nextMutationBatch(this.lastBatchSeen)\n        .then(batch => {\n          if (batch === null) {\n            if (this.pendingWrites.length === 0) {\n              this.writeStream.markIdle();\n            }\n          } else {\n            this.commit(batch);\n            return this.fillWritePipeline();\n          }\n        });\n    }\n  }\n\n  /**\n   * Returns true if the backend can accept additional write requests.\n   *\n   * When sending mutations to the write stream (e.g. in fillWritePipeline),\n   * call this method first to check if more mutations can be sent.\n   *\n   * Currently the only thing that can prevent the backend from accepting\n   * write requests is if there are too many requests already outstanding. As\n   * writes complete the backend will be able to accept more.\n   */\n  canWriteMutations(): boolean {\n    return (\n      this.isNetworkEnabled() && this.pendingWrites.length < MAX_PENDING_WRITES\n    );\n  }\n\n  // For testing\n  outstandingWrites(): number {\n    return this.pendingWrites.length;\n  }\n\n  /**\n   * Given mutations to commit, actually commits them to the Datastore. Note\n   * that this does *not* return a Promise specifically because the AsyncQueue\n   * should not block operations for this.\n   */\n  private commit(batch: MutationBatch): void {\n    assert(\n      this.canWriteMutations(),\n      \"commit called when batches can't be written\"\n    );\n    this.lastBatchSeen = batch.batchId;\n\n    this.pendingWrites.push(batch);\n\n    if (this.shouldStartWriteStream()) {\n      this.startWriteStream();\n    } else if (this.isNetworkEnabled() && this.writeStream.handshakeComplete) {\n      this.writeStream.writeMutations(batch.mutations);\n    }\n  }\n\n  private shouldStartWriteStream(): boolean {\n    return (\n      this.isNetworkEnabled() &&\n      !this.writeStream.isStarted() &&\n      this.pendingWrites.length > 0\n    );\n  }\n\n  private startWriteStream(): void {\n    assert(\n      this.shouldStartWriteStream(),\n      'startWriteStream() called when shouldStartWriteStream() is false.'\n    );\n    this.writeStream.start({\n      onOpen: this.onWriteStreamOpen.bind(this),\n      onClose: this.onWriteStreamClose.bind(this),\n      onHandshakeComplete: this.onWriteHandshakeComplete.bind(this),\n      onMutationResult: this.onMutationResult.bind(this)\n    });\n  }\n\n  private async onWriteStreamOpen(): Promise<void> {\n    this.writeStream.writeHandshake();\n  }\n\n  private onWriteHandshakeComplete(): Promise<void> {\n    // Record the stream token.\n    return this.localStore\n      .setLastStreamToken(this.writeStream.lastStreamToken)\n      .then(() => {\n        // Drain any pending writes.\n        //\n        // Note that at this point pendingWrites contains mutations that\n        // have already been accepted by fillWritePipeline/commitBatch. If\n        // the pipeline is full, canWriteMutations will be false, despite\n        // the fact that we actually need to send mutations over.\n        //\n        // This also means that this method indirectly respects the limits\n        // imposed by canWriteMutations since writes can't be added to the\n        // pendingWrites array when canWriteMutations is false. If the\n        // limits imposed by canWriteMutations actually protect us from\n        // DOSing ourselves then those limits won't be exceeded here and\n        // we'll continue to make progress.\n        for (const batch of this.pendingWrites) {\n          this.writeStream.writeMutations(batch.mutations);\n        }\n      });\n  }\n\n  private onMutationResult(\n    commitVersion: SnapshotVersion,\n    results: MutationResult[]\n  ): Promise<void> {\n    // This is a response to a write containing mutations and should be\n    // correlated to the first pending write.\n    assert(\n      this.pendingWrites.length > 0,\n      'Got result for empty pending writes'\n    );\n    const batch = this.pendingWrites.shift()!;\n    const success = MutationBatchResult.from(\n      batch,\n      commitVersion,\n      results,\n      this.writeStream.lastStreamToken\n    );\n    return this.syncEngine.applySuccessfulWrite(success).then(() => {\n      // It's possible that with the completion of this mutation another\n      // slot has freed up.\n      return this.fillWritePipeline();\n    });\n  }\n\n  private async onWriteStreamClose(error?: FirestoreError): Promise<void> {\n    assert(\n      this.isNetworkEnabled(),\n      'onWriteStreamClose() should only be called when the network is enabled'\n    );\n\n    // If the write stream closed due to an error, invoke the error callbacks if\n    // there are pending writes.\n    if (error && this.pendingWrites.length > 0) {\n      assert(\n        !!error,\n        'We have pending writes, but the write stream closed without an error'\n      );\n      // A promise that is resolved after we processed the error\n      let errorHandling: Promise<void>;\n      if (this.writeStream.handshakeComplete) {\n        // This error affects the actual write.\n        errorHandling = this.handleWriteError(error!);\n      } else {\n        // If there was an error before the handshake has finished, it's\n        // possible that the server is unable to process the stream token\n        // we're sending. (Perhaps it's too old?)\n        errorHandling = this.handleHandshakeError(error!);\n      }\n\n      return errorHandling.then(() => {\n        // The write stream might have been started by refilling the write\n        // pipeline for failed writes\n        if (this.shouldStartWriteStream()) {\n          this.startWriteStream();\n        }\n      });\n    }\n    // No pending writes, nothing to do\n  }\n\n  private async handleHandshakeError(error: FirestoreError): Promise<void> {\n    // Reset the token if it's a permanent error or the error code is\n    // ABORTED, signaling the write stream is no longer valid.\n    if (isPermanentError(error.code) || error.code === Code.ABORTED) {\n      log.debug(\n        LOG_TAG,\n        'RemoteStore error before completed handshake; resetting stream token: ',\n        this.writeStream.lastStreamToken\n      );\n      this.writeStream.lastStreamToken = emptyByteString();\n\n      return this.localStore.setLastStreamToken(emptyByteString());\n    } else {\n      // Some other error, don't reset stream token. Our stream logic will\n      // just retry with exponential backoff.\n    }\n  }\n\n  private async handleWriteError(error: FirestoreError): Promise<void> {\n    if (isPermanentError(error.code)) {\n      // This was a permanent error, the request itself was the problem\n      // so it's not going to succeed if we resend it.\n      const batch = this.pendingWrites.shift()!;\n\n      // In this case it's also unlikely that the server itself is melting\n      // down -- this was just a bad request so inhibit backoff on the next\n      // restart.\n      this.writeStream.inhibitBackoff();\n\n      return this.syncEngine\n        .rejectFailedWrite(batch.batchId, error)\n        .then(() => {\n          // It's possible that with the completion of this mutation\n          // another slot has freed up.\n          return this.fillWritePipeline();\n        });\n    } else {\n      // Transient error, just let the retry logic kick in.\n    }\n  }\n\n  createTransaction(): Transaction {\n    return new Transaction(this.datastore);\n  }\n\n  handleUserChange(user: User): Promise<void> {\n    log.debug(LOG_TAG, 'RemoteStore changing users: uid=', user.uid);\n\n    // If the network has been explicitly disabled, make sure we don't\n    // accidentally re-enable it.\n    if (this.isNetworkEnabled()) {\n      // Tear down and re-create our network streams. This will ensure we get a fresh auth token\n      // for the new user and re-fill the write pipeline with new mutations from the LocalStore\n      // (since mutations are per-user).\n      this.disableNetworkInternal();\n      this.onlineStateTracker.set(OnlineState.Unknown);\n      return this.enableNetwork();\n    }\n  }\n}\n"]}