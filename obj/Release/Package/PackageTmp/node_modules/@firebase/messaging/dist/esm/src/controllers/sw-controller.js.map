{"version":3,"sources":["../src/controllers/sw-controller.ts"],"names":[],"mappings":"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","file":"sw-controller.js","sourcesContent":["/**\n * Copyright 2017 Google Inc.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n'use strict';\n\nimport ControllerInterface from './controller-interface';\nimport Errors from '../models/errors';\nimport FCMDetails from '../models/fcm-details';\nimport WorkerPageMessage from '../models/worker-page-message';\n\nconst FCM_MSG = 'FCM_MSG';\n\nexport default class SWController extends ControllerInterface {\n  private bgMessageHandler_: (input: Object) => Promise<any>;\n\n  constructor(app) {\n    super(app);\n\n    self.addEventListener('push', e => this.onPush_(e), false);\n    self.addEventListener(\n      'pushsubscriptionchange',\n      e => this.onSubChange_(e),\n      false\n    );\n    self.addEventListener(\n      'notificationclick',\n      e => this.onNotificationClick_(e),\n      false\n    );\n\n    /**\n     * @private\n     * @type {function(Object)|null}\n     */\n    this.bgMessageHandler_ = null;\n  }\n\n  /**\n   * A handler for push events that shows notifications based on the content of\n   * the payload.\n   *\n   * The payload must be a JSON-encoded Object with a `notification` key. The\n   * value of the `notification` property will be used as the NotificationOptions\n   * object passed to showNotification. Additionally, the `title` property of the\n   * notification object will be used as the title.\n   *\n   * If there is no notification data in the payload then no notification will be\n   * shown.\n   * @private\n   */\n  onPush_(event) {\n    let msgPayload;\n    try {\n      msgPayload = event.data.json();\n    } catch (err) {\n      // Not JSON so not an FCM message\n      return;\n    }\n\n    const handleMsgPromise = this.hasVisibleClients_().then(\n      hasVisibleClients => {\n        if (hasVisibleClients) {\n          // Do not need to show a notification.\n          if (msgPayload.notification || this.bgMessageHandler_) {\n            // Send to page\n            return this.sendMessageToWindowClients_(msgPayload);\n          }\n          return;\n        }\n\n        const notificationDetails = this.getNotificationData_(msgPayload);\n        if (notificationDetails) {\n          const notificationTitle = notificationDetails.title || '';\n          return (this.getSWRegistration_() as any).then(reg => {\n            return reg.showNotification(notificationTitle, notificationDetails);\n          });\n        } else if (this.bgMessageHandler_) {\n          return this.bgMessageHandler_(msgPayload);\n        }\n      }\n    );\n\n    event.waitUntil(handleMsgPromise);\n  }\n\n  /**\n   * @private\n   */\n  onSubChange_(event) {\n    const promiseChain = this.getSWRegistration_()\n      .then(registration => {\n        return registration.pushManager\n          .getSubscription()\n          .then(subscription => {\n            // TODO: Check if it's still valid\n            // TODO: If not, then update token\n          })\n          .catch(err => {\n            // The best thing we can do is log this to the terminal so\n            // developers might notice the error.\n            const tokenDetailsModel = this.getTokenDetailsModel();\n            return tokenDetailsModel\n              .getTokenDetailsFromSWScope(registration.scope)\n              .then(tokenDetails => {\n                if (!tokenDetails) {\n                  // This should rarely occure, but could if indexedDB\n                  // is corrupted or wiped\n                  throw err;\n                }\n\n                // Attempt to delete the token if we know it's bad\n                return this.deleteToken(tokenDetails['fcmToken']).then(() => {\n                  throw err;\n                });\n              });\n          });\n      })\n      .catch(err => {\n        throw this.errorFactory_.create(Errors.codes.UNABLE_TO_RESUBSCRIBE, {\n          message: err\n        });\n      });\n\n    event.waitUntil(promiseChain);\n  }\n\n  /**\n   * @private\n   */\n  onNotificationClick_(event) {\n    if (\n      !(\n        event.notification &&\n        event.notification.data &&\n        event.notification.data[FCM_MSG]\n      )\n    ) {\n      // Not an FCM notification, do nothing.\n      return;\n    }\n\n    // Prevent other listeners from receiving the event\n    event.stopImmediatePropagation();\n\n    event.notification.close();\n\n    const msgPayload = event.notification.data[FCM_MSG];\n    if (!msgPayload['notification']) {\n      // Nothing to do.\n      return;\n    }\n\n    const clickAction = msgPayload['notification']['click_action'];\n    if (!clickAction) {\n      // Nothing to do.\n      return;\n    }\n\n    const promiseChain = this.getWindowClient_(clickAction)\n      .then(windowClient => {\n        if (!windowClient) {\n          // Unable to find window client so need to open one.\n          return (self as any).clients.openWindow(clickAction);\n        }\n\n        return windowClient.focus();\n      })\n      .then(windowClient => {\n        if (!windowClient) {\n          // Window Client will not be returned if it's for a third party origin.\n          return;\n        }\n\n        // Delete notification data from payload before sending to the page.\n        const notificationData = msgPayload['notification'];\n        delete msgPayload['notification'];\n\n        const internalMsg = WorkerPageMessage.createNewMsg(\n          WorkerPageMessage.TYPES_OF_MSG.NOTIFICATION_CLICKED,\n          msgPayload\n        );\n        // Attempt to send a message to the client to handle the data\n        // Is affected by: https://github.com/slightlyoff/ServiceWorker/issues/728\n        return this.attemptToMessageClient_(windowClient, internalMsg);\n      });\n\n    event.waitUntil(promiseChain);\n  }\n\n  /**\n   * @private\n   * @param {Object} msgPayload\n   * @return {NotificationOptions|undefined}\n   */\n  getNotificationData_(msgPayload) {\n    if (!msgPayload) {\n      return;\n    }\n\n    if (typeof msgPayload.notification !== 'object') {\n      return;\n    }\n\n    const notificationInformation = Object.assign({}, msgPayload.notification);\n    // Put the message payload under FCM_MSG name so we can identify the\n    // notification as being an FCM notification vs a notification from\n    // somewhere else (i.e. normal web push or developer generated\n    // notification).\n    notificationInformation['data'] = {\n      [FCM_MSG]: msgPayload\n    };\n\n    return notificationInformation;\n  }\n\n  /**\n   * Calling setBackgroundMessageHandler will opt in to some specific\n   * behaviours.\n   * 1.) If a notification doesn't need to be shown due to a window already\n   * being visible, then push messages will be sent to the page.\n   * 2.) If a notification needs to be shown, and the message contains no\n   * notification data this method will be called\n   * and the promise it returns will be passed to event.waitUntil.\n   * If you do not set this callback then all push messages will let and the\n   * developer can handle them in a their own 'push' event callback\n   * @export\n   * @param {function(Object)} callback The callback to be called when a push\n   * message is received and a notification must be shown. The callback will\n   * be given the data from the push message.\n   */\n  setBackgroundMessageHandler(callback) {\n    if (!callback || typeof callback !== 'function') {\n      throw this.errorFactory_.create(\n        Errors.codes.BG_HANDLER_FUNCTION_EXPECTED\n      );\n    }\n\n    this.bgMessageHandler_ = callback;\n  }\n\n  /**\n   * @private\n   * @param {string} url The URL to look for when focusing a client.\n   * @return {Object} Returns an existing window client or a newly opened\n   * WindowClient.\n   */\n  getWindowClient_(url) {\n    // Use URL to normalize the URL when comparing to windowClients.\n    // This at least handles whether to include trailing slashes or not\n    const parsedURL = new URL(url, (self as any).location).href;\n\n    return (self as any).clients\n      .matchAll({\n        type: 'window',\n        includeUncontrolled: true\n      })\n      .then(clientList => {\n        let suitableClient = null;\n        for (let i = 0; i < clientList.length; i++) {\n          const parsedClientUrl = new URL(\n            clientList[i].url,\n            (self as any).location\n          ).href;\n          if (parsedClientUrl === parsedURL) {\n            suitableClient = clientList[i];\n            break;\n          }\n        }\n\n        if (suitableClient) {\n          return suitableClient;\n        }\n\n        return null;\n      });\n  }\n\n  /**\n   * This message will attempt to send the message to a window client.\n   * @private\n   * @param {Object} client The WindowClient to send the message to.\n   * @param {Object} message The message to send to the client.\n   * @returns {Promise} Returns a promise that resolves after sending the\n   * message. This does not guarantee that the message was successfully\n   * received.\n   */\n  async attemptToMessageClient_(client, message) {\n    // NOTE: This returns a promise in case this API is abstracted later on to\n    // do additional work\n    if (!client) {\n      return Promise.reject(\n        this.errorFactory_.create(Errors.codes.NO_WINDOW_CLIENT_TO_MSG)\n      );\n    }\n\n    client.postMessage(message);\n  }\n\n  /**\n   * @private\n   * @returns {Promise<boolean>} If there is currently a visible WindowClient,\n   * this method will resolve to true, otherwise false.\n   */\n  hasVisibleClients_() {\n    return (self as any).clients\n      .matchAll({\n        type: 'window',\n        includeUncontrolled: true\n      })\n      .then(clientList => {\n        return clientList.some(client => client.visibilityState === 'visible');\n      });\n  }\n\n  /**\n   * @private\n   * @param {Object} msgPayload The data from the push event that should be sent\n   * to all available pages.\n   * @returns {Promise} Returns a promise that resolves once the message\n   * has been sent to all WindowClients.\n   */\n  sendMessageToWindowClients_(msgPayload) {\n    return (self as any).clients\n      .matchAll({\n        type: 'window',\n        includeUncontrolled: true\n      })\n      .then(clientList => {\n        const internalMsg = WorkerPageMessage.createNewMsg(\n          WorkerPageMessage.TYPES_OF_MSG.PUSH_MSG_RECEIVED,\n          msgPayload\n        );\n\n        return Promise.all(\n          clientList.map(client => {\n            return this.attemptToMessageClient_(client, internalMsg);\n          })\n        );\n      });\n  }\n\n  /**\n   * This will register the default service worker and return the registration.\n   * @private\n   * @return {Promise<!ServiceWorkerRegistration>} The service worker\n   * registration to be used for the push service.\n   */\n  getSWRegistration_() {\n    return Promise.resolve((self as any).registration);\n  }\n\n  /**\n   * This will return the default VAPID key or the uint8array version of the\n   * public VAPID key provided by the developer.\n   */\n  getPublicVapidKey_(): Promise<Uint8Array> {\n    return this.getSWRegistration_()\n      .then(swReg => {\n        return this.getVapidDetailsModel().getVapidFromSWScope(swReg.scope);\n      })\n      .then(vapidKeyFromDatabase => {\n        if (vapidKeyFromDatabase === null) {\n          return FCMDetails.DEFAULT_PUBLIC_VAPID_KEY;\n        }\n        return vapidKeyFromDatabase;\n      });\n  }\n}\n"]}